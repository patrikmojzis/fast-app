{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Fast App","text":"<p>Fast App is an async, Laravel-inspired toolkit for building HTTP APIs on Quart + Motor (MongoDB). It ships a batteries-included core (routes, schemas, models, resources, middleware, events) with optional extras like queues, scheduling, broadcasting, notifications, storage, and a CLI.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>MongoDB (required)</li> <li>Optional: Redis (cache/socket.io/scheduler), RabbitMQ (<code>async_farm</code> queue)</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\npip install \"git+https://github.com/patrikmojzis/fast-app\"\nfast-app init\nfast-app serve\n</code></pre> <p>Then open <code>http://localhost:8000</code>.</p>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Start with the Getting Started section in the sidebar</li> <li>Review Routes, Schemas, Models, and Resources to build your API</li> <li>See Hosting when you are ready to deploy</li> </ul>"},{"location":"api/","title":"API Helpers","text":"<p><code>fast_app.core.api</code> provides validation, pagination, and filtering utilities to keep controllers clean. This module handles request/query parsing, Pydantic validation, async rule checks, and common pagination patterns.</p>"},{"location":"api/#request-validation","title":"Request validation","text":""},{"location":"api/#validate_requestschema-partialfalse","title":"<code>validate_request(schema, *, partial=False)</code>","text":"<p>Parse and validate JSON request bodies. Returns the schema instance and stores the validated dictionary in <code>quart.g.validated</code>.</p> <pre><code>from fast_app.core.api import validate_request\nfrom quart import g\n\nasync def store(data: LeadSchema):\n    # `data` is the schema instance, `data.validated` is the dict\n    lead = await Lead.create(data.validated)\n    return LeadResource(lead)\n</code></pre> <ul> <li>Runs Pydantic field validation first.</li> <li>If the schema extends <code>fast_validation.Schema</code>, calls <code>await schema.validate(partial=partial)</code> to run async rules.</li> <li>Raises <code>UnprocessableEntityException</code> (422) on validation failure with sanitized error details.</li> </ul>"},{"location":"api/#validate_queryschema-partialfalse","title":"<code>validate_query(schema, *, partial=False)</code>","text":"<p>Parse and validate query parameters. Returns the schema instance and stores the validated dictionary in <code>g.validated_query</code>.</p> <pre><code>from fast_app.core.api import validate_query\n\nclass LeadIndexFilter(Schema):\n    source: Literal[\"direct\", \"eshop\", \"pharmacy\"] | None = None\n    rep_id: ObjectIdField | None = None\n    is_highlighted: bool | None = None\n\n    class Meta:\n        rules = [\n            Schema.Rule(\"$.rep_id\", [ExistsValidatorRule(allow_null=True)]),\n        ]\n\n# Route.get(\"/lead\", lead_controller.index)\nasync def index(filter: LeadIndexFilter):\n    # filter is validated automatically\n    return await list_paginated(Lead, LeadResource, filter=filter)\n</code></pre> <p>When you omit the model, <code>ExistsValidatorRule</code> infers it from the field name (e.g., <code>rep_id</code> \u2192 <code>Rep</code>).</p> <p>The helper intelligently collects query parameters:</p> <ul> <li>Scalar fields: <code>?rep_id=abc123</code> \u2192 <code>{\"rep_id\": \"abc123\"}</code></li> <li>List fields: <code>?tags=a&amp;tags=b</code> or <code>?tags[]=a&amp;tags[]=b</code> or <code>?tags=a,b,c</code> \u2192 all merged into a list</li> <li>Type coercion happens during Pydantic validation</li> </ul>"},{"location":"api/#pagination","title":"Pagination","text":"<p>FastApp includes three pagination helpers that return <code>{meta, data}</code> dictionaries ready for JSON serialization.</p>"},{"location":"api/#list_paginatedmodel-resource-filternone-sortnone","title":"<code>list_paginated(model, resource, *, filter=None, sort=None)</code>","text":"<p>Standard pagination with count + find. Accepts query parameters <code>page</code>, <code>per_page</code>, <code>sort_by</code>, <code>sort_direction</code>.</p> <pre><code>from fast_app.core.api import list_paginated\n\nasync def index():\n    return await list_paginated(Lead, LeadResource)\n</code></pre> <p>Meta response includes <code>total</code>, <code>current_page</code>, <code>per_page</code>, <code>last_page</code>, <code>skip</code>, <code>displaying</code>.</p>"},{"location":"api/#search_paginatedmodel-resource-filternone-sortnone","title":"<code>search_paginated(model, resource, *, filter=None, sort=None)</code>","text":"<p>Text search across model fields via <code>model.search()</code>. Requires query parameter <code>search</code> plus pagination params.</p> <pre><code>async def search():\n    return await search_paginated(Lead, LeadResource)\n</code></pre>"},{"location":"api/#paginatemodel-resource-filternone-sortnone","title":"<code>paginate(Model, Resource, *, filter=None, sort=None)</code>","text":"<p>Convenience wrapper: checks for <code>?search=...</code> and delegates to <code>search_paginated</code> or <code>list_paginated</code> accordingly.</p> <pre><code>async def index():\n    return await paginate(Lead, LeadResource)\n</code></pre>"},{"location":"api/#filtering","title":"Filtering","text":""},{"location":"api/#schema-based-filters","title":"Schema-based filters","text":"<p>Pass a validated schema instance to <code>filter</code> to restrict results. The schema is converted to a dictionary (via <code>model_dump(exclude_unset=True)</code>) and merged with the base query.</p> <pre><code>class LeadIndexFilter(Schema):\n    source: Literal[\"direct\", \"eshop\", \"pharmacy\", \"distributor\"] | None = None\n    county_id: ObjectIdField | None = None\n    is_highlighted: bool | None = None\n\n    class Meta:\n        rules = [\n            Schema.Rule(\"$.county_id\", [ExistsValidatorRule(allow_null=True)]),\n        ]\n\nasync def index(filter: LeadIndexFilter):\n    return await paginate(Lead, LeadResource, filter=filter)\n</code></pre> <p>Unset fields are excluded, so only provided filters apply.</p>"},{"location":"api/#get_mongo_filter_from_query-param_namefilter-allowed_fieldsnone-allowed_opsnone","title":"<code>get_mongo_filter_from_query(*, param_name=\"filter\", allowed_fields=None, allowed_ops=None)</code>","text":"<p>Parse a JSON (or base64-JSON) Mongo filter from the query string with strict operator and field allowlists.</p> <pre><code>from fast_app.core.api import get_mongo_filter_from_query\n\nasync def advanced_index():\n    extra_filter = get_mongo_filter_from_query(\n        allowed_fields=[\"name\", \"tags\", \"created_at\"],\n        allowed_ops=[\"$eq\", \"$in\", \"$gte\", \"$lte\"],\n    )\n    return await list_paginated(Item, ItemResource, filter=extra_filter)\n</code></pre> <p>Clients can send complex queries:</p> <pre><code>?filter={\"name\":{\"$in\":[\"A\",\"B\"]},\"created_at\":{\"$gte\":\"2024-01-01\"}}\n</code></pre> <p>or base64-encoded for URL safety. The helper validates operators/fields and raises <code>UnprocessableEntityException</code> if disallowed constructs appear.</p> <p>Default allowed operators include <code>$and</code>, <code>$or</code>, <code>$eq</code>, <code>$ne</code>, <code>$gt</code>, <code>$gte</code>, <code>$lt</code>, <code>$lte</code>, <code>$in</code>, <code>$nin</code>, <code>$exists</code>, <code>$regex</code>, <code>$size</code>, <code>$all</code>, <code>$elemMatch</code>.</p>"},{"location":"api/#request-helpers","title":"Request helpers","text":""},{"location":"api/#get_client_ip","title":"<code>get_client_ip()</code>","text":"<p>Extract the client's IP address from <code>X-Forwarded-For</code>, <code>X-Real-IP</code>, or fallback to <code>request.remote_addr</code>. Useful for logging, rate limiting, or geolocation.</p> <pre><code>from fast_app.core.api import get_client_ip\n\nasync def track():\n    ip = get_client_ip()\n    await log_access(ip)\n</code></pre>"},{"location":"api/#get_bearer_token","title":"<code>get_bearer_token()</code>","text":"<p>Parse the <code>Authorization: Bearer &lt;token&gt;</code> header and return the token string, or <code>None</code> if absent.</p> <pre><code>from fast_app.core.api import get_bearer_token\n\nasync def validate_custom_auth():\n    token = get_bearer_token()\n    if token:\n        user = await verify_jwt(token)\n</code></pre> <p>Raises <code>AppException</code> if called outside a request context.</p>"},{"location":"api/#tips","title":"Tips","text":"<ul> <li>Use <code>partial=True</code> in <code>validate_request</code> / <code>validate_query</code> for PATCH endpoints to skip unset fields.</li> <li>Combine schema filters with <code>get_mongo_filter_from_query</code> for admin endpoints that need flexible querying.</li> <li>Pagination helpers run <code>model.count()</code> and <code>model.find()</code> concurrently via <code>asyncio.gather</code> for better performance.</li> <li>Schema-based filters leverage async rule validation, so you can enforce relational constraints (e.g., <code>ExistsValidatorRule</code>) before hitting the database.</li> </ul> <p>With these helpers, controllers stay thin and focused on orchestration while validation and data fetching logic lives in reusable, testable utilities.</p>"},{"location":"async_farm/","title":"Async Farm Workers","text":"<p>The async farm handles background job execution. Operators launch it with <code>fast-app work</code> in production, or with <code>fast-app work --tui</code> / <code>fast-app work --verbose</code> during development to get live diagnostics.</p>"},{"location":"async_farm/#system-overview","title":"System Overview","text":"<p>Async farm is a RabbitMQ-backed worker pool with three core components:</p> <ul> <li>Supervisor (<code>fast_app.integrations.async_farm.supervisor.AsyncFarmSupervisor</code>) \u2014 manages queue connections, spawns worker processes, and scales the pool.</li> <li>Worker (<code>fast_app.integrations.async_farm.worker.AsyncFarmWorker</code>) \u2014 consumes jobs from <code>async_farm.jobs</code>, executes callables, and streams status back.</li> <li>Publisher API (<code>fast_app.integrations.async_farm.publisher.AsyncFarmPublisher</code>) \u2014 enqueues jobs by serialising the target callable plus arguments.</li> </ul> <p>Internally, job messages carry the dotted import path of the callable (<code>func_path</code>), positional/keyword arguments, optional request context, and soft/hard timeout headers. The worker dynamically imports the callable, restores context, and executes it (async or sync via <code>asyncio.to_thread</code>). stdout/stderr/log output is captured and sent back to the supervisor.</p>"},{"location":"async_farm/#rabbitmq-contracts","title":"RabbitMQ contracts","text":"Purpose Default Override via Broker URL <code>amqp://guest:guest@localhost:5672/</code> <code>RABBITMQ_URL</code> Jobs queue <code>async_farm.jobs</code> <code>ASYNC_FARM_JOBS_QUEUE</code> Supervisor \u2192 Worker exchange (fanout) <code>async_farm.supervisor</code> <code>ASYNC_FARM_CONTROL_EXCHANGE</code> Worker \u2192 Supervisor exchange (direct) <code>async_farm.worker</code> <code>ASYNC_FARM_WORKER_EXCHANGE</code> <p>Workers declare exclusive control queues bound to the fanout exchange so they can receive shutdown or snapshot requests. Supervisors consume a dedicated queue for heartbeat and task events.</p>"},{"location":"async_farm/#running-the-supervisor","title":"Running the Supervisor","text":"<p>The CLI wrapper instantiates <code>AsyncFarmSupervisor</code>, boots the FastApp container, and enters several async loops:</p> <ul> <li><code>spawn_worker()</code> \u2014 starts new worker processes (forked via <code>multiprocessing.Process</code>).</li> <li><code>heartbeat_loop()</code> \u2014 periodically broadcasts heartbeats to workers, ensuring they stay connected.</li> <li><code>scaling_loop()</code> \u2014 inspects queue depth vs available capacity and scales worker count up/down within configured bounds.</li> <li><code>keep_alive_loop()</code> \u2014 handles graceful shutdown, sending <code>shutdown</code> commands and joining worker processes with a grace period.</li> <li><code>monitor_workers_heartbeat_loop()</code> \u2014 watches for stale heartbeats and terminates hung workers.</li> </ul>"},{"location":"async_farm/#scaling-heuristics","title":"Scaling heuristics","text":"<ul> <li>Maintain at least <code>MIN_WORKERS</code> live processes (default 1).</li> <li>Cap the pool at <code>MAX_WORKERS</code> (default 10) to avoid runaway costs.</li> <li>Check queue length every <code>SCALE_CHECK_INTERVAL_S</code> seconds (default 1).</li> <li>Scale up in batches of <code>SCALE_UP_BATCH_SIZE</code> (default 2) when backlog exceeds aggregate capacity (<code>prefetch_per_worker \u00d7 alive workers</code>).</li> <li>Scale down by terminating idle workers in batches of <code>SCALE_DOWN_BATCH_SIZE</code> (default 1) when load is light.</li> </ul> <p>All values hydrate from environment variables at supervisor start. Tweaking them lets you optimise for latency or resource usage.</p>"},{"location":"async_farm/#shutdown-lifecycle","title":"Shutdown lifecycle","text":"<ol> <li>Request shutdown (signal handler or CLI exit).</li> <li>Publish <code>shutdown</code> control message with a grace period (<code>WORKER_SHUTDOWN_GRACE_S</code>, default 15s).</li> <li>Wait for worker processes to exit normally (<code>await_processes_death</code>).</li> <li>Terminate remaining workers, then force-kill if necessary.</li> <li>Close AMQP channels cleanly.</li> </ol> <p>Workers reciprocate by cancelling their job consumers, draining in-flight tasks (bounded by the largest soft timeout), and recording completion snapshots.</p>"},{"location":"async_farm/#worker-execution-model","title":"Worker Execution Model","text":"<p>Each worker keeps a bounded number of concurrent tasks (<code>PREFETCH_PER_WORKER</code>, default 10). For every message:</p> <ol> <li>Wrap it in a <code>Task</code> (loads args, deadlines, context snapshot).</li> <li>Register lifecycle callbacks for success/failure/timeouts.</li> <li>Execute the callable (async natively or offloaded to a thread).</li> <li>Capture stdout/stderr/logging and attach to the task snapshot.</li> <li>Ack the message once callbacks finish.</li> </ol> <p>Timeout handling:</p> <ul> <li>Soft timeout \u2014 marks the task as <code>soft_timeout</code>, cancels the asyncio wrapper, and notifies the supervisor, but lets the underlying work finish until the hard timeout.</li> <li>Hard timeout \u2014 publishes an event, ack\u2019s the job, records the logs, and requests worker shutdown (followed by a forced exit after a 2-minute safety window).</li> </ul>"},{"location":"async_farm/#supervisor-watchdog","title":"Supervisor watchdog","text":"<p>Workers track the last heartbeat from the supervisor. If it stalls longer than <code>7 \u00d7 HEARTBEAT_INTERVAL_S</code>, the worker self-terminates to avoid orphaned consumers.</p>"},{"location":"async_farm/#publishing-jobs","title":"Publishing Jobs","text":"<p>Use <code>AsyncFarmPublisher</code> (or the convenience helpers in your application) to enqueue work:</p> <pre><code>publisher = AsyncFarmPublisher()\nawait publisher.publish(\n    func_path=\"app.jobs.send_welcome_email\",\n    args=(user_id,),\n    kwargs={\"urgent\": True},\n    context_snapshot=context.snapshot(),\n    soft_timeout_s=10,\n    hard_timeout_s=60,\n)\n</code></pre> <p>Jobs are pickled, optionally compressed, and durable. Consumers must stay compatible with the message schema; deploy new workers before enqueuing messages that rely on new code paths.</p>"},{"location":"async_farm/#operational-tips","title":"Operational Tips","text":"<ul> <li>Monitoring \u2014 Run <code>fast-app work --tui</code> to launch the textual dashboard (<code>SupervisorTUI</code>). It displays live worker status, task logs, and lets you request snapshots.</li> <li>Logging \u2014 <code>--verbose</code> keeps supervisor prints enabled. In production, rely on structured logging forwarded from workers.</li> <li>Graceful deploys \u2014 set <code>WORKER_SHUTDOWN_GRACE_S</code> to cover your longest soft timeout. Rolling restarts ensure no job is dropped mid-flight.</li> <li>Backpressure \u2014 tune <code>PREFETCH_PER_WORKER</code> to balance throughput vs fairness. High values increase parallelism but can starve slow tasks.</li> <li>Isolation \u2014 each worker process bootstraps FastApp (<code>fast_app.boot</code>) before executing tasks, so application singletons and bindings are fresh per process.</li> <li>Failure recovery \u2014 periodic heartbeats and supervisor watchdogs terminate zombie workers. RabbitMQ redelivers unacked messages when a worker shuts down.</li> </ul>"},{"location":"async_farm/#environment-configuration-summary","title":"Environment Configuration Summary","text":"<pre><code>MIN_WORKERS=1\nMAX_WORKERS=10\nPREFETCH_PER_WORKER=10\nSCALE_UP_BATCH_SIZE=2\nSCALE_DOWN_BATCH_SIZE=1\nSCALE_CHECK_INTERVAL_S=1.0\nWORKER_SHUTDOWN_GRACE_S=15\nHEARTBEAT_INTERVAL_S=1\nRABBITMQ_URL=amqp://guest:guest@localhost:5672/\nASYNC_FARM_JOBS_QUEUE=async_farm.jobs\nASYNC_FARM_CONTROL_EXCHANGE=async_farm.supervisor\nASYNC_FARM_WORKER_EXCHANGE=async_farm.worker\nTASK_HISTORY_MAX=300\n</code></pre> <p>Values may be overridden per deployment. The CLI reads them at process start, so restart the supervisor after changing config.</p>"},{"location":"broadcast_events/","title":"Broadcast Events","text":"<p>Broadcast events describe the payload delivered to clients and the rooms that should receive it. They extend <code>fast_app.contracts.broadcast_event.BroadcastEvent</code>, which itself inherits from the base <code>Event</code> contract.</p>"},{"location":"broadcast_events/#generating-an-event","title":"Generating an event","text":"<pre><code>fast-app make broadcast_event UpdateChat\n</code></pre> <p>This creates <code>app/socketio/events/update_chat.py</code>. Keep events under <code>app/socketio/events/</code> so autodiscovery and imports remain tidy.</p>"},{"location":"broadcast_events/#defining-an-event","title":"Defining an event","text":"<pre><code>from typing import TYPE_CHECKING, Union\n\nfrom fast_app import BroadcastEvent\nfrom app.http_files.resources.chat_resource import ChatResource\nfrom app.socketio.rooms.chat_room import ChatRoom\nfrom app.models.chat import Chat\n\nif TYPE_CHECKING:\n    from fast_app import Room\n\n\nclass UpdateChat(BroadcastEvent):\n    chat: Chat\n\n    async def broadcast_on(self) -&gt; Union[str, \"Room\"]:\n        return ChatRoom(self.chat.id)\n\n    async def broadcast_as(self):\n        return ChatResource(self.chat)\n</code></pre> <p>Key methods:</p> <ul> <li><code>broadcast_on()</code> \u2014 return a room string, a <code>Room</code> instance, or a list of either. The helper <code>fast_app.utils.broadcast_utils.get_broadcast_ons</code> normalizes to <code>{room, namespace}</code> pairs.</li> <li><code>broadcast_when()</code> \u2014 override to conditionally skip broadcasting; default returns <code>True</code>.</li> <li><code>broadcast_as()</code> \u2014 transform the payload. Returning a Resource automatically serializes through <code>Resource.dump()</code>; Pydantic models (<code>model_dump</code>) are supported as well.</li> </ul>"},{"location":"broadcast_events/#emitting-events","title":"Emitting events","text":"<p>Call <code>await broadcast(event_instance)</code> from anywhere in your application (controllers, observers, background jobs). Example:</p> <pre><code>from fast_app.core.broadcasting import broadcast\nfrom app.socketio.events.update_chat import UpdateChat\n\n\nasync def notify_chat_updated(chat: Chat) -&gt; None:\n    await broadcast(UpdateChat(chat=chat))\n</code></pre> <p>Internally, <code>broadcast</code> checks <code>broadcast_when()</code>, resolves rooms via <code>broadcast_on()</code>, transforms the payload, and emits through a Redis Socket.IO manager.</p>"},{"location":"broadcast_events/#tips","title":"Tips","text":"<ul> <li>Use resources to keep event payloads consistent with your HTTP API.</li> <li>Broadcast from observers or domain services to notify clients about model changes without duplicating logic.</li> <li>Namespaces default to <code>/</code>; pass a <code>Room</code> with a custom namespace if you need separation.</li> <li>Combine with async farm workers to broadcast from background jobs (the Redis manager handles fan-out across processes).</li> </ul> <p>Broadcast events decouple real-time delivery from controller logic, ensuring clients stay in sync with minimal effort.</p>"},{"location":"broadcasting/","title":"Broadcasting Basics","text":"<p>FastApp ships with a Socket.IO-compatible broadcasting layer. Events are serialized through Redis and delivered to connected clients using rooms and namespaces. This guide explains the moving parts and how to wire them together.</p>"},{"location":"broadcasting/#core-pieces","title":"Core pieces","text":"<ul> <li>Broadcast events (<code>app/socketio/events/</code>) \u2014 subclasses of <code>fast_app.contracts.broadcast_event.BroadcastEvent</code>. They define the payload and channel.</li> <li>Rooms (<code>app/socketio/rooms/</code>) \u2014 subclasses of <code>fast_app.contracts.room.Room</code>. They resolve room identifiers and enforce access control.</li> <li>Namespaces (<code>app/socketio/namespaces/</code>) \u2014 Socket.IO namespaces (usually <code>AsyncNamespace</code>) decorated with <code>@register_room</code> so the framework knows which rooms to expose.</li> <li>Broadcast function \u2014 <code>fast_app.core.broadcasting.broadcast(event)</code> transforms the event into JSON (resources supported) and emits it to Redis.</li> </ul> <p>Recommended structure (mirrors the sample project):</p> <pre><code>app/\n  socketio/\n    common/\n      authentication.py\n    events/\n      update_chat.py\n    rooms/\n      chat_room.py\n    namespaces/\n      global_namespace.py\n</code></pre>"},{"location":"broadcasting/#redis-and-socketio","title":"Redis and Socket.IO","text":"<p>FastApp uses <code>socketio.AsyncRedisManager</code> under the hood. Configure the manager through <code>REDIS_SOCKETIO_URL</code> (defaults to <code>redis://localhost:6379/14</code>). Each <code>broadcast()</code> call emits to all rooms defined by the event\u2019s <code>broadcast_on()</code> method. Clients subscribe by connecting to the namespace/room combination.</p>"},{"location":"broadcasting/#flow-overview","title":"Flow overview","text":"<ol> <li>Client connects to a namespace; <code>on_connect</code> authenticates and stores user details in the Socket.IO session.</li> <li>Client joins rooms by emitting events handled by your namespace/room combination.</li> <li>Server-side code triggers a <code>BroadcastEvent</code> (e.g., inside a controller or observer) and calls <code>await broadcast(event)</code>.</li> <li>Redis manager emits to every subscribed worker; workers forward to connected clients.</li> </ol>"},{"location":"broadcasting/#setting-up-the-structure","title":"Setting up the structure","text":"<p>Before building individual events and rooms, scaffold the base Socket.IO structure:</p> <pre><code>fast-app publish socketio\n</code></pre> <p>This copies the recommended folder layout into your project:</p> <ul> <li><code>app/modules/asgi/socketio.py</code> \u2014 Socket.IO server initialization</li> <li><code>app/socketio/common/authentication.py</code> \u2014 authentication helper</li> <li><code>app/socketio/namespaces/global_namespace.py</code> \u2014 default namespace stub</li> <li><code>app/socketio/events/</code> \u2014 placeholder for broadcast events</li> <li><code>app/socketio/rooms/</code> \u2014 placeholder for room classes</li> </ul> <p>Once the structure is in place, use CLI generators to add individual components:</p> <pre><code>fast-app make room ChatRoom\nfast-app make broadcast_event UpdateChat\n</code></pre> <p>The generators populate the directories with minimal stubs ready for customization.</p> <p>With these pieces in place, broadcasting becomes a matter of instantiating events and calling <code>broadcast()</code>. The following sections dive into room definitions and event classes in more detail.</p>"},{"location":"cli/","title":"CLI Overview","text":"<p>FastApp ships with a modular CLI. Run <code>fast-app -h</code> from a project root to list commands.</p> <ul> <li><code>init</code> \u2014 scaffold a new FastApp project in the current directory</li> <li><code>make</code> \u2014 generate code from templates (models, resources, middlewares, etc.)</li> <li><code>publish</code> \u2014 copy optional feature modules (socketio, notification channels)</li> <li><code>migrate</code> / <code>seed</code> \u2014 execute your app-level database migrations and seeders</li> <li><code>serve</code> \u2014 run the development ASGI server via Hypercorn with auto-reload</li> <li><code>work</code> \u2014 start the async_farm worker supervisor (with optional TUI)</li> <li><code>exec</code> \u2014 discover and run app-specific async commands from <code>app/cli</code></li> <li><code>version</code> \u2014 print the installed FastApp version</li> </ul> <p>All commands accept <code>-h</code>/<code>--help</code> for detailed usage.</p>"},{"location":"cli/#command-reference","title":"Command Reference","text":""},{"location":"cli/#fast-app-init","title":"<code>fast-app init</code>","text":"<p>Scaffold the starter project (using templates under <code>fast_app/templates/project_structure</code>).</p> <pre><code>fast-app init\n</code></pre> <p>Copies the template files into the current directory and prints suggested next steps.</p>"},{"location":"cli/#fast-app-make","title":"<code>fast-app make</code>","text":"<p>Create boilerplate files from FastApp templates.</p> <pre><code>fast-app make &lt;type&gt; &lt;Name&gt;\n</code></pre> <p>Common types include <code>model</code>, <code>resource</code>, <code>schema</code>, <code>middleware</code>, <code>observer</code>, <code>policy</code>, <code>event</code>, <code>factory</code>, <code>migration</code>, <code>command</code>, <code>room</code>, and more (see <code>fast_app/cli/make_command.py</code>).</p> <p>Example:</p> <pre><code>fast-app make model User\nfast-app make resource UserResource\nfast-app make schema UserSchema\nfast-app make middleware AuthMiddleware\nfast-app make observer UserObserver\n</code></pre> <p>You can override the destination directory with <code>--path</code> (relative to the project root):</p> <pre><code>fast-app make observer UserObserver --path app/observers/custom\n</code></pre>"},{"location":"cli/#fast-app-publish","title":"<code>fast-app publish</code>","text":"<p>Copy optional packaged modules into your project.</p> <pre><code>fast-app publish &lt;package&gt;\n</code></pre> <p>Available packages live in <code>fast_app/templates/publish</code>. If you request an unknown package, the CLI lists the available ones.</p>"},{"location":"cli/#fast-app-migrate","title":"<code>fast-app migrate</code>","text":"<p>Run a migration from <code>app/db/migrations/&lt;name&gt;.py</code>.</p> <pre><code>fast-app migrate AddIndexToUsers\n</code></pre> <p>The command loads the migration module, prefers classes implementing <code>fast_app.contracts.migration.Migration</code>, and falls back to legacy functions (<code>migrate()</code>, <code>run()</code>). It reports success or failure in the console.</p> <p>Override the migrations directory with <code>--path</code> (relative to the project root):</p> <pre><code>fast-app migrate AddIndexToUsers --path app/db/migrations\n</code></pre>"},{"location":"cli/#fast-app-seed","title":"<code>fast-app seed</code>","text":"<p>Execute a seeder from <code>app/db/seeders/&lt;name&gt;.py</code>.</p> <pre><code>fast-app seed UserSeeder\n</code></pre> <p>Supports contract-based seeders (implementing <code>fast_app.contracts.seeder.Seeder</code>) and legacy <code>seed()</code> / <code>run()</code> functions.</p> <p>Override the seeders directory with <code>--path</code> (relative to the project root):</p> <pre><code>fast-app seed UserSeeder --path app/db/seeders\n</code></pre>"},{"location":"cli/#fast-app-serve","title":"<code>fast-app serve</code>","text":"<p>Launch the development Hypercorn server with auto-reload.</p> <pre><code>fast-app serve [--bind 0.0.0.0:8000] [--app app.modules.asgi.app:app] [--reload-dir path]\n</code></pre> <ul> <li>Enforces <code>--reload</code> and <code>--debug</code> flags automatically.</li> <li>Watches the project and optional directories for changes.</li> <li><code>--log-level</code> allows overriding the default <code>debug</code> noise level.</li> </ul> <p>Intended for local development only.</p>"},{"location":"cli/#fast-app-work","title":"<code>fast-app work</code>","text":"<p>Start the async_farm supervisor to process background jobs.</p> <pre><code>fast-app work [--tui] [--verbose]\n</code></pre> <ul> <li>Default mode runs the supervisor until shutdown.</li> <li><code>--tui</code> launches the interactive dashboard (<code>SupervisorTUI</code>).</li> <li>Respects environment variables such as <code>MIN_WORKERS</code>, <code>MAX_WORKERS</code>, and <code>PREFETCH_PER_WORKER</code> for tuning.</li> </ul>"},{"location":"cli/#fast-app-exec","title":"<code>fast-app exec</code>","text":"<p>Discover and run async commands defined in your app\u2019s <code>app/cli</code> package.</p> <pre><code>fast-app exec --list               # show available commands\nfast-app exec reports:daily --date 2024-01-01\n</code></pre> <ul> <li>Auto-discovers classes extending <code>fast_app.Command</code> under <code>app/cli</code>.</li> <li>Supports an optional <code>app.cli.provider.get_commands()</code> hook for manual registration.</li> <li>Validates that command <code>execute()</code> methods are async; otherwise raises an error.</li> </ul> <p>Override the app command directory with <code>--path</code> (relative to the project root):</p> <pre><code>fast-app exec --list --path app/cli/admin\n</code></pre>"},{"location":"cli/#fast-app-version","title":"<code>fast-app version</code>","text":"<p>Print the installed FastApp version (reads <code>pyproject.toml</code> first, then package metadata).</p> <pre><code>fast-app version\n</code></pre> <p>Useful for confirming the framework version in CI or debugging.</p>"},{"location":"context/","title":"Context","text":""},{"location":"context/#context","title":"Context","text":"<p>Central, typed runtime context built on Python ContextVars.</p> <ul> <li>Per-request/task values that are easy to set/get anywhere.</li> <li>Optional strong typing via <code>ContextKey[T]</code> returned by <code>define_key</code>.</li> <li>Safe cross-process propagation via a picklable snapshot (used by the queue worker automatically).</li> </ul>"},{"location":"context/#quick-start","title":"Quick start","text":"<pre><code>from fast_app import context\n\n# Use plain strings (no typing)\ncontext.set(\"request_id\", \"req-42\")\nrid = context.get(\"request_id\")\n\n# Or define typed keys\nfrom fast_app import define_key\nUserId = define_key[int](\"user_id\", require_picklable=True)\n\ncontext.set(UserId, 123)\nuid: int | None = context.get(UserId)\n</code></pre>"},{"location":"context/#defining-keys-vs-strings","title":"Defining keys vs. strings","text":"<ul> <li>Strings work fine for small apps: <code>context.set(\"tenant\", \"local\")</code>.</li> <li><code>define_key[T](name, default=None, require_picklable=False)</code> is recommended for larger apps/libraries:</li> <li>Strong typing on get/set</li> <li>Per-key defaults</li> <li><code>require_picklable=True</code> to enforce cross-process propagation compatibility</li> </ul>"},{"location":"context/#picklability-and-propagation","title":"Picklability and propagation","text":"<p>Context values are propagated to worker processes by sending a pickled snapshot.</p> <ul> <li>Non-picklable values:</li> <li>Normal keys: setting a non-picklable value emits a RuntimeWarning once per key; the value is omitted from snapshots.</li> <li><code>require_picklable=True</code> keys: setting a non-picklable value raises <code>TypeError</code> immediately.</li> </ul> <pre><code>Socket = define_key(\"socket\")  # normal key\ncontext.set(Socket, object())   # warns once; won't propagate to workers\n\nStrict = define_key(\"trace_id\", require_picklable=True)\ncontext.set(Strict, object())   # raises TypeError\n</code></pre>"},{"location":"context/#snapshot-and-install","title":"Snapshot and install","text":"<p>You usually don\u2019t need this directly because the queue publisher/worker handle it for you. If you implement your own transport, use:</p> <pre><code>from fast_app import context\n\nsnap = context.snapshot()  # picklable-only dict\n# ... send snap to another process ...\ncontext.install(snap)      # restore values in the target process\n</code></pre>"},{"location":"context/#queue-integration","title":"Queue integration","text":"<p>When using the <code>async_farm</code> queue driver:</p> <ul> <li>The publisher includes <code>ctx_snapshot</code> (picklable-only) and app boot args in the job payload.</li> <li>The worker installs the snapshot and boots the app before running your callable.</li> <li>You don\u2019t need to write any extra code; values you put in the context are available inside the worker.</li> </ul> <pre><code>from fast_app import define_key, context\nfrom fast_app.core.queue import queue\n\nCorrelationId = define_key[str](\"corr_id\", require_picklable=True)\ncontext.set(CorrelationId, \"abc-123\")\n\ndef do_work():\n    from fast_app import context\n    assert context.get(\"corr_id\") == \"abc-123\"\n\nawait queue(do_work)\n</code></pre>"},{"location":"context/#api-surface","title":"API surface","text":"<ul> <li><code>define_key[T](name, default=None, require_picklable=False) -&gt; ContextKey[T]</code></li> <li><code>context.set(key_or_name, value) -&gt; None</code></li> <li><code>context.get(key_or_name, default=None)</code></li> <li><code>context.clear(*names) -&gt; None</code> (no names = clear known keys back to defaults)</li> <li><code>context.snapshot(picklable_only=True, include_defaults=True) -&gt; dict[str, Any]</code></li> <li><code>context.install(mapping: dict[str, Any]) -&gt; None</code></li> </ul>"},{"location":"controller/","title":"Controllers","text":"<p>Controllers orchestrate request handling: validate payloads, invoke domain logic, and return resources. Because FastApp leans on dependency injection for route parameters, controllers can stay thin and focused.</p>"},{"location":"controller/#typical-layout","title":"Typical layout","text":"<p>Place controllers under <code>app/http_files/controllers/</code>.</p> <p>Controllers are regular Python modules exporting async functions. Combine them with schemas, models, and resources for a clean flow.</p> <pre><code>from typing import Literal\n\nfrom fast_app import Schema, ExistsValidatorRule, paginate\nfrom fast_app.core.pydantic_types import ObjectIdField\nfrom quart import g\nfrom pydantic import Field\n\nfrom app.http_files.resources.lead_resource import LeadResource\nfrom app.http_files.schemas.lead_schema import LeadSchema\nfrom app.models.lead import Lead\nfrom app.models.rep import Rep\nfrom app.models.county import County\n\nasync def index():\n    return await paginate(Lead, LeadResource)\n\n\nasync def show(lead: Lead):\n    return LeadResource(lead)\n\n\nasync def store(data: LeadSchema):\n    lead = await Lead.create(data.validated)\n    return LeadResource(lead)\n\n\nasync def update(lead: Lead, data: LeadSchema):\n    await lead.update(data.validated)\n    return LeadResource(lead)\n\n\nasync def destroy(lead: Lead):\n    await lead.delete()\n</code></pre>"},{"location":"controller/#patterns-for-larger-controllers","title":"Patterns for larger controllers","text":"<ul> <li>Services: move complex business logic into <code>app/http_files/services</code> or domain modules; keep controllers as coordinators.</li> </ul> <p>Controllers are intentionally lightweight: they accept validated inputs, call domain services, and wrap outputs. With schemas and resources handling validation and presentation, controllers stay easy to read and test.</p>"},{"location":"enviroment/","title":"Environment","text":""},{"location":"enviroment/#environment-configuration-env","title":"Environment configuration (.env)","text":"<p>This project reads configuration from environment variables. For local development, use <code>.env.debug</code>. For production or generic usage, use <code>.env</code> or your platform's environment manager. Docker uses <code>.env.docker</code> with <code>docker-compose.yml</code>.</p>"},{"location":"enviroment/#how-env-files-are-loaded","title":"How env files are loaded","text":"<ul> <li>Local dev: <code>ENV=debug</code> causes the loader to try <code>.env.debug</code> first, then <code>.env</code> (<code>fast_app/utils/env_utils.configure_env</code>).</li> <li>Non\u2011debug or explicit file: you can pass an explicit file to the loader; otherwise rely on real environment variables.</li> <li>Debug mode effects: extra console logging and more verbose HTTP error output.</li> </ul> <p>Minimal required to run the app (without Docker):</p> <pre><code>ENV=debug\nMONGO_URI=mongodb://localhost:27017\nSECRET_KEY=change-me\n</code></pre> <p>Optionally set:</p> <pre><code>DB_NAME=fast-app         # defaults to \"db\"\nLOG_LEVEL=DEBUG          # defaults to INFO\n</code></pre>"},{"location":"enviroment/#variables-by-area","title":"Variables by area","text":""},{"location":"enviroment/#application-and-logging","title":"Application and logging","text":"<ul> <li><code>ENV</code> (debug|test|prod): controls debug behaviors (console logging, verbose errors). Default: <code>debug</code> in loader logic.</li> <li><code>LOG_LEVEL</code> (CRITICAL|ERROR|WARNING|INFO|DEBUG|NOTSET): root logger level. Default: <code>INFO</code>.</li> <li>Localization:</li> <li><code>LOCALE_DEFAULT</code> (default <code>en</code>)</li> <li><code>LOCALE_FALLBACK</code> (default <code>en</code>)</li> <li><code>LOCALE_PATH</code> (default <code>&lt;project&gt;/lang</code>)</li> </ul>"},{"location":"enviroment/#database-mongodb","title":"Database (MongoDB)","text":"<ul> <li><code>MONGO_URI</code> (required): Mongo connection string. Used in <code>fast_app/database/mongo.py</code>.</li> <li><code>DB_NAME</code> (optional): DB name for normal runs. Default: <code>db</code>.</li> <li>Testing support:</li> <li><code>TEST_ENV</code> (flag): when set, test DB is used.</li> <li><code>TEST_DB_NAME</code> (optional): test DB name. Default: <code>test_db</code>.</li> </ul>"},{"location":"enviroment/#jwtauth","title":"JWT/Auth","text":"<ul> <li><code>SECRET_KEY</code> (required): JWT signing key. Enforced by runtime checks.</li> <li><code>AUTH_JWT_ALGORITHM</code> (optional): Default <code>HS256</code>.</li> <li><code>ACCESS_TOKEN_LIFETIME</code> (seconds, optional): Default <code>900</code> (15 min).</li> <li><code>REFRESH_TOKEN_LIFETIME</code> (seconds, optional): Default <code>604800</code> (7 days).</li> </ul>"},{"location":"enviroment/#redis-hostport-shared","title":"Redis (host/port shared)","text":"<ul> <li><code>REDIS_CACHE_URL</code> (optional): Default <code>redis://localhost:6379/15</code>.</li> <li><code>REDIS_SOCKETIO_URL</code> (optional): Default <code>redis://localhost:6379/14</code>.</li> <li><code>REDIS_DATABASE_CACHE_URL</code> (optional): Default <code>redis://localhost:6379/13</code>.</li> <li><code>REDIS_SCHEDULER_URL</code> (optional): Default <code>redis://localhost:6379/12</code>.</li> </ul>"},{"location":"enviroment/#queue","title":"Queue","text":"<ul> <li><code>QUEUE_DRIVER</code> (optional): <code>sync</code> or <code>async_farm</code>. Default: <code>sync</code>.</li> <li><code>RABBITMQ_URL</code> (optional): RabbitMQ connection for async_farm. Default: <code>amqp://guest:guest@localhost:5672/</code>.</li> <li><code>ASYNC_FARM_JOBS_QUEUE</code> (optional): Job queue name. Default: <code>async_farm.jobs</code>.</li> <li><code>SOFT_TIMEOUT_S</code> (optional): Default soft timeout for queued jobs.</li> <li><code>HARD_TIMEOUT_S</code> (optional): Default hard timeout for queued jobs.</li> </ul>"},{"location":"enviroment/#email-notifications","title":"Email notifications","text":"<ul> <li><code>MAIL_DRIVER</code> (optional): <code>log</code> (default) or <code>smtp</code>.</li> <li>If <code>smtp</code>:</li> <li><code>MAIL_SERVER</code></li> <li><code>MAIL_PORT</code></li> <li><code>MAIL_LOGIN</code></li> <li><code>MAIL_PASSWORD</code></li> <li><code>MAIL_FROM</code></li> </ul>"},{"location":"enviroment/#log-watcher-integrations","title":"Log watcher integrations","text":"<ul> <li>Slack: <code>SEND_LOG_ERRORS_SLACK_WEBHOOK_URL</code> (optional). Includes current <code>ENV</code> in messages.</li> <li>Telegram: <code>SEND_LOG_ERRORS_TELEGRAM_BOT_TOKEN</code>, <code>SEND_LOG_ERRORS_TELEGRAM_CHAT_ID</code> (optional).</li> </ul>"},{"location":"enviroment/#auth-integrations","title":"Auth integrations","text":"<ul> <li>Google: <code>GOOGLE_CLIENT_ID</code> (optional, token verification).</li> <li>Apple: <code>APPLE_CLIENT_ID</code>, <code>APPLE_TEAM_ID</code>, <code>APPLE_KEY_ID</code>, <code>APPLE_P8_KEY</code> (optional; required if Apple auth is enabled).</li> </ul>"},{"location":"enviroment/#push-notifications","title":"Push notifications","text":"<ul> <li>Expo: <code>EXPO_AUTHORIZATION_TOKEN</code> (optional).</li> </ul>"},{"location":"enviroment/#docker-compose-variables","title":"Docker Compose variables","text":"<p><code>fast_app/templates/project_structure/docker-compose.yml</code> reads from <code>.env.docker</code> and inlines some values: - <code>APP_NAME</code>: used for container and network naming. Default: <code>fast_app</code>. - <code>MAP_ASGI_PORT</code>: host\u2192container port mapping for API (default host <code>8000</code>). - Containers set <code>REDIS_HOST=redis</code> internally; you usually don\u2019t override this inside the compose network.  - Redis and RabbitMQ ports are not published to the host by default (internal-only).</p>"},{"location":"enviroment/#recommended-example-files","title":"Recommended example files","text":"<p>Local development (<code>.env.debug</code>):</p> <pre><code>ENV=debug\nMONGO_URI=mongodb://localhost:27017\nSECRET_KEY=dev-secret-key-not-for-production\n\n# Optional (uncomment as needed)\n# DB_NAME=fast-app\n# LOG_LEVEL=DEBUG\n# REDIS_HOST=localhost\n# REDIS_PORT=6379\n# QUEUE_DRIVER=sync           # or async_farm\n# RABBITMQ_URL=amqp://guest:guest@localhost:5672/\n# AUTH_JWT_ALGORITHM=HS256\n# ACCESS_TOKEN_LIFETIME=900\n# REFRESH_TOKEN_LIFETIME=604800\n# LOCALE_DEFAULT=en\n# LOCALE_FALLBACK=en\n# LOCALE_PATH=\n# MAIL_DRIVER=log             # or smtp\n# MAIL_SERVER=\n# MAIL_PORT=\n# MAIL_LOGIN=\n# MAIL_PASSWORD=\n# MAIL_FROM=\n# SEND_LOG_ERRORS_SLACK_WEBHOOK_URL=\n# SEND_LOG_ERRORS_TELEGRAM_BOT_TOKEN=\n# SEND_LOG_ERRORS_TELEGRAM_CHAT_ID=\n# GOOGLE_CLIENT_ID=\n# APPLE_CLIENT_ID=\n# APPLE_TEAM_ID=\n# APPLE_KEY_ID=\n# APPLE_P8_KEY=\n# EXPO_AUTHORIZATION_TOKEN=\n</code></pre> <p>Docker (<code>.env.docker</code>):</p> <pre><code>APP_NAME=fast_app\nMAP_ASGI_PORT=8000\n\n# App/runtime variables are also read inside containers via env_file\n# e.g., MONGO_URI, SECRET_KEY, etc.\n</code></pre>"},{"location":"enviroment/#notes","title":"Notes","text":"<ul> <li>Keep secrets like <code>SECRET_KEY</code>, credentials, and webhooks out of version control.</li> <li>Use the smallest possible <code>.env.*</code> files: required keys only; refer back to this page for all optional settings.</li> </ul>"},{"location":"events/","title":"Events","text":"<p>Events decouple side effects from controllers and models. Instead of triggering actions directly (e.g., sending emails, logging, updating cache), dispatch events and let listeners handle them asynchronously via the queue.</p>"},{"location":"events/#why-use-events","title":"Why use events?","text":"<ul> <li>Decouple logic \u2014 controllers remain focused on request handling; observers avoid business logic bloat</li> <li>Asynchronous execution \u2014 listeners run in background workers (async farm) without blocking responses</li> <li>Testability \u2014 test event dispatch separately from listener implementations</li> <li>Extensibility \u2014 add new listeners to existing events without modifying core code</li> </ul>"},{"location":"events/#generating-events-and-listeners","title":"Generating events and listeners","text":"<p>Use the CLI to scaffold event and listener classes:</p> <pre><code>fast-app make event NewChatEvent\nfast-app make listener GenerateChatTitle\n</code></pre> <p>Events land in <code>app/events/</code>, listeners in <code>app/listeners/</code>.</p>"},{"location":"events/#defining-an-event","title":"Defining an event","text":"<p>Events extend <code>fast_app.Event</code> (a Pydantic model) and carry typed data:</p> <pre><code>from bson import ObjectId\nfrom fast_app import Event\nfrom pydantic import Field\n\n\nclass NewChatEvent(Event):\n    chat_id: ObjectId = Field(..., description=\"The ID of the chat\")\n</code></pre> <p>Events are immutable data containers; keep them focused on a single domain action.</p>"},{"location":"events/#creating-a-listener","title":"Creating a listener","text":"<p>Listeners extend <code>fast_app.EventListener</code> and implement <code>async def handle(self, event)</code>:</p> <pre><code>from typing import TYPE_CHECKING\n\nfrom fast_app import EventListener\n\nif TYPE_CHECKING:\n    from app.events.new_chat_event import NewChatEvent\n\n\nclass GenerateChatTitle(EventListener):\n    async def handle(self, event: \"NewChatEvent\") -&gt; None:\n        from app.models.chat import Chat\n\n        chat = await Chat.find_by_id(event.chat_id)\n        if not chat or not chat.input_history:\n            return\n\n        # Generate title using AI or logic\n        title = generate_title_from_message(chat.input_history[0])\n        await chat.update({\"title\": title})\n</code></pre> <p>Use <code>TYPE_CHECKING</code> imports to avoid circular dependencies while retaining type hints.</p>"},{"location":"events/#registering-events","title":"Registering events","text":"<p>Wire events to listeners in <code>app/event_provider.py</code>:</p> <pre><code>from typing import TYPE_CHECKING, Dict, List, Type\n\nif TYPE_CHECKING:\n    from fast_app import Event, EventListener\n\nfrom app.events.new_chat_event import NewChatEvent\nfrom app.events.new_user_message import NewUserMessage\nfrom app.listeners.generate_chat_title import GenerateChatTitle\nfrom app.listeners.new_message_listener import NewMessageListener\n\n\nevents: Dict[Type[\"Event\"], List[Type[\"EventListener\"]]] = {\n    NewChatEvent: [GenerateChatTitle],\n    NewUserMessage: [NewMessageListener],\n}\n</code></pre> <p>The <code>events</code> dictionary maps each event class to a list of listeners. FastApp reads this during <code>import fast_app.boot</code> and configures the event system.</p>"},{"location":"events/#dispatching-events","title":"Dispatching events","text":"<p>Call <code>dispatch(event_instance)</code> from anywhere in your application\u2014controllers, observers, background jobs:</p> <pre><code>from fast_app.core.events import dispatch\nfrom app.events.new_chat_event import NewChatEvent\n\n\nasync def create_chat():\n    chat = await Chat.create({\"user_id\": user.id})\n    await dispatch(NewChatEvent(chat_id=chat.id))\n    return ChatResource(chat)\n</code></pre>"},{"location":"events/#how-dispatch-works","title":"How dispatch works","text":"<ol> <li><code>dispatch(event)</code> serializes the event and enqueues each registered listener via <code>fast_app.core.queue.queue</code>.</li> <li>If <code>QUEUE_DRIVER=async_farm</code>, listeners execute on worker processes managed by <code>fast-app work</code>.</li> <li>If <code>QUEUE_DRIVER=sync</code>, listeners run immediately in-process (useful for tests or lightweight deployments).</li> </ol> <p>Context variables (<code>fast_app.core.context.context</code>) are preserved, so listeners have access to the same user/locale/etc. that was active when the event was dispatched.</p>"},{"location":"events/#immediate-execution","title":"Immediate execution","text":"<p>For tests or synchronous flows, use <code>dispatch_now(event)</code> to await all listeners without queueing:</p> <pre><code>from fast_app.core.events import dispatch_now\n\nawait dispatch_now(UserRegistered(user_id=\"123\"))\n</code></pre> <p>This blocks until every listener completes.</p>"},{"location":"events/#tips","title":"Tips","text":"<ul> <li>Keep events focused on a single domain action; split complex flows into multiple events.</li> <li>Use listeners for side effects (emails, notifications, analytics) rather than core business logic.</li> <li>Test event dispatch by asserting the event was queued; test listeners by invoking <code>listener.handle(event)</code> directly.</li> <li>Combine with observers for model-specific hooks; use events for cross-cutting or multi-step workflows.</li> </ul> <p>Events give you a clean, testable pattern for decoupling application behavior from request handling.</p>"},{"location":"factories/","title":"Factories","text":"<p>Factories give you a fast way to produce realistic model instances. They are perfect for tests, seeders, fixtures, or any scenario where you need repeatable sample data without hand\u2011crafting dictionaries every time.</p>"},{"location":"factories/#generate-a-factory-stub","title":"Generate a factory stub","text":"<p>Use the CLI to scaffold a factory:</p> <pre><code>fast-app make factory UserFactory\n</code></pre> <p>This command creates <code>app/db/factories/user_factory.py</code> with a class named <code>UserFactory</code>. As long as the class name follows the <code>&lt;Model&gt;Factory</code> pattern and lives in that directory, FastApp will discover it automatically during boot and register it on the matching model (<code>User.factory</code>).</p> <p>Need a custom location or name? Import <code>register_factory</code> from <code>fast_app.decorators</code> and attach your factory manually:</p> <p>```python from fast_app.decorators import register_factory from app.db.factories.user_factory import UserFactory</p> <p>@register_factory(UserFactory) class User(Model):     ... ```</p>"},{"location":"factories/#defining-attributes","title":"Defining attributes","text":"<p>Inside your new factory, declare fields using the helper descriptors:</p> <pre><code>from datetime import datetime, timezone\n\nfrom fast_app.contracts.factory import Factory, Faker, Value, CallableAttribute, Function\nfrom app.models.user import User\n\n\nclass UserFactory(Factory[User]):\n    name = Faker(\"name\")                   # uses the optional Faker dependency\n    email = Faker(\"email\")\n    status = Value(\"active\")               # always the same value\n    nickname = CallableAttribute(lambda faker: f\"{faker.color()}-fox\")\n    expires_at = Function(lambda: datetime.now(timezone.utc))\n</code></pre> <ul> <li><code>Faker(...)</code> pulls data from the Faker provider (install <code>fast-app[dev]</code> or add Faker to your project).</li> <li><code>Value(...)</code> returns a constant every time.</li> <li><code>CallableAttribute(...)</code> lets you compute values yourself. The callable receives the shared Faker instance (or <code>None</code> when Faker is not installed, if you pass <code>requires_faker=False</code>).</li> <li><code>Function(...)</code> calls any function you give it\u2014perfect for timestamps like <code>datetime.utcnow</code>.</li> </ul> <p>Any keyword arguments you pass when calling the factory will override these defaults.</p>"},{"location":"factories/#factory-api-at-a-glance","title":"Factory API at a glance","text":"Method Description <code>User.factory.build(**overrides)</code> Returns an unsaved model instance. Great for tests where you do not need the database. <code>await User.factory.create(**overrides)</code> Persists the model and returns the saved instance. <code>await User.factory.seed(count, **overrides)</code> Bulk insert <code>count</code> documents efficiently, returning the created instances. <code>User.factory.count(n).build()</code> Batch helper that repeats any factory call <code>n</code> times (<code>create</code> and <code>seed</code> also available). <code>User.factory.with_related(...)</code> Creates related models alongside the parent and fills foreign keys automatically. <p>Every method accepts overrides, so <code>await User.factory.create(name=\"Jane Doe\")</code> replaces only that attribute.</p>"},{"location":"factories/#creating-related-models","title":"Creating related models","text":"<p>Use <code>with_related</code> when a model depends on another document (e.g. <code>User</code> belongs to <code>Business</code>):</p> <pre><code>class BusinessFactory(Factory[Business]):\n    name = Faker(\"company\")\n\n\nclass UserFactory(Factory[User]):\n    name = Faker(\"name\")\n    email = Faker(\"email\")\n\n# Create a business and associate its _id with the new user\nuser = await User.factory.with_related(Business, {\"name\": \"Acme Inc.\"}).create()\nassert user.business_id is not None\n</code></pre> <p>Arguments:</p> <ul> <li>First parameter can be the related model class or its string name (<code>\"business\"</code>). FastApp resolves it using the same naming conventions as autodiscovery.</li> <li>Provide per-relation overrides in the second argument (e.g. to set a specific business name).</li> <li>Optional keywords:</li> <li><code>factory=</code> lets you specify an explicit factory if the model does not have one registered.</li> <li><code>foreign_key=</code> overrides the default <code>&lt;collection&gt;_id</code> field name.</li> </ul> <p><code>with_related</code> returns a fresh factory instance, so you can chain calls:</p> <pre><code>await Order.factory \\\n    .with_related(Customer, {\"email\": \"client@example.com\"}) \\\n    .with_related(\"product\", {\"sku\": \"SKU-123\"}) \\\n    .create()\n</code></pre>"},{"location":"factories/#tips-gotchas","title":"Tips &amp; gotchas","text":"<ul> <li>Faker is optional. If you rely on Faker-powered attributes, make sure the dependency is installed in the environment that runs the factory.</li> <li>Factories live on the model. Once registered, every model exposes a <code>.factory</code> attribute. You can still instantiate your factory class directly if you prefer.</li> <li>Asynchronous by design. <code>create</code>, <code>seed</code>, and any method that calls them are <code>async</code> because they interact with the database.</li> <li>Bulk seeding respects fillable fields. Factories automatically drop protected attributes (<code>_id</code>, <code>created_at</code>, <code>updated_at</code>) unless you supply them explicitly.</li> </ul> <p>With a handful of declarations you get consistent, expressive data builders that fit seamlessly into tests, seeders, and prototypes. Happy scaffolding!</p>"},{"location":"installation/","title":"FastApp","text":"<p>FastApp is a pragmatic, Laravel\u2011flavoured toolkit for building backend APIs with Python. It composes Quart (HTTP), Pydantic (validation), and Motor (Mongo) so you can ship features fast without wiring the same pieces every time.</p>"},{"location":"installation/#quick-start","title":"Quick start","text":"<p>1) Create and activate a virtualenv</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate   # Windows: .venv\\\\Scripts\\\\activate\n</code></pre> <p>2) Install FastApp</p> <pre><code>pip install \"git+https://github.com/patrikmojzis/fast-app\"\n</code></pre> <p>3) Scaffold a new project</p> <pre><code>fast-app init\n</code></pre> <p>4) Configure .env</p> <pre><code>cp .env.example .env\n</code></pre> <p>5) Run the API</p> <pre><code>fast-app serve          # runs hypercorn from app.modules.asgi.app:app\n</code></pre>"},{"location":"installation/#hello-api-in-60-seconds","title":"Hello API in 60 seconds","text":"<pre><code>import fast_app.boot  # Always first\n\nfrom quart import Quart\nfrom pydantic import constr\nfrom fast_app import Route, Schema, Model, Resource\nfrom fast_app.utils.routing_utils import register_routes\nfrom fast_app.core.pydantic_types import ShortStr\n\nclass Item(Model):\n    name: str\n\nclass ItemResource(Resource):\n    async def to_dict(self, item: Item):\n        return {\n            \"name\": item.name\n        }\n\nclass ItemSchema(Schema):\n    name: ShortStr\n\nasync def create_item(data: ItemSchema):\n    item = await Item.create(data.model_dump())\n    return ItemResource(item)\n\napp = Quart(__name__)\nroutes = [\n    Route.post(\"/item\", create_item),\n]\nregister_routes(app, routes)\n</code></pre> <p>Note: Every Python entry point must import <code>fast_app.boot</code> first to initialize logging, environment, and autodiscovery. See Quick Start for details.</p>"},{"location":"integrations/","title":"Integrations","text":"<p><code>fast_app/integrations</code></p> <p>Optional batteries you can opt into:</p> <ul> <li>auth: helpers for Apple/Google auth</li> <li>notification_channels: mail, telegram, expo</li> <li>storage_drivers: e.g. S3 via boto3</li> <li>log_watcher: ship log errors to Slack/Telegram</li> </ul>"},{"location":"integrations/#project-templates-and-publishable-modules","title":"Project templates and publishable modules","text":"<ul> <li><code>templates/project_structure</code>: minimal runnable skeleton</li> <li><code>templates/publish</code>: optional feature modules</li> </ul> <p>Use <code>fast-app publish &lt;module&gt;</code> to copy selected features into your app.</p>"},{"location":"localization/","title":"Localization","text":""},{"location":"localization/#localization","title":"localization","text":"<p>Drop translations into JSON files and reach for them anywhere in my app with a tiny helper. The locale lives in context, so each request transparently picks up its own language without extra plumbing.</p>"},{"location":"localization/#prepare-translations","title":"Prepare translations","text":"<ul> <li>Create a <code>lang/</code> directory (the default lookup path) next to my entry point or point the helper elsewhere with <code>set_locale_path()</code> or <code>LOCALE_PATH</code>.</li> <li>Add <code>&lt;locale&gt;.json</code> files such as <code>lang/en.json</code>. Dot keys map to nested dictionaries:</li> </ul> <p><code>json   {     \"messages\": {       \"welcome\": \"Welcome back, {name}!\"     },     \"cart_count\": \"You have {count} item\",     \"cart_count_plural\": \"You have {count} items\"   }</code></p>"},{"location":"localization/#pick-the-locale","title":"Pick the locale","text":"<ul> <li><code>LOCALE_DEFAULT</code> decides the starting locale (defaults to <code>en</code>). Override it in <code>.env</code> or at runtime with <code>set_locale(\"cs\")</code>. The value is stored in a context variable, so each async task or request keeps its own setting.</li> <li><code>LOCALE_FALLBACK</code> (defaults to <code>en</code>) provides a second chance when the active locale lacks a key.</li> <li>If the folder contents were changed on the fly, use <code>clear_cache()</code> to wipe cache.</li> </ul>"},{"location":"localization/#translate-in-code","title":"Translate in code","text":"<pre><code>from fast_app.core.localization import __, set_locale\n\nset_locale(\"en\")\nmessage = __(\"messages.welcome\", {\"name\": \"Alice\"}, default=\"Hello {name}\")\n</code></pre> <ul> <li><code>__()</code> looks up the key using dot notation, applies the parameters with <code>str.format</code>, and falls back to the key (or <code>default=</code>) when nothing is found.</li> <li>Passing <code>locale=\"es\"</code> lets me force a one-off translation without touching the global context.</li> </ul>"},{"location":"localization/#handle-plurals","title":"Handle plurals","text":"<ul> <li><code>trans_choice(\"cart_count\", count, {\"count\": count})</code> automatically checks <code>cart_count_plural</code> when <code>count != 1</code> and otherwise reuses <code>cart_count</code>.</li> </ul>"},{"location":"localization/#environment-cheat-sheet","title":"Environment cheat sheet","text":"<ul> <li><code>LOCALE_PATH</code>: absolute or relative path to my JSON files (defaults to <code>&lt;cwd&gt;/lang</code>).</li> <li><code>LOCALE_DEFAULT</code>: initial locale for new contexts.</li> <li><code>LOCALE_FALLBACK</code>: locale used when the active one misses a key.</li> </ul> <p>TLDR:  - Drop JSON files in <code>app/lang</code> (e.g. <code>en.json</code>), - Set the locale per request when necessary with <code>set_locale(\"en\")</code> or env <code>LOCALE_DEFAULT</code> - Call <code>__()</code> or <code>trans_choice()</code> wherever you need translated strings.</p>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Fast App ships with a collection of route middleware that help you compose behaviour around your handlers. Each middleware is applied through the <code>@middleware</code> decorator and receives the fully-bound handler arguments. This section covers four core middlewares you are likely to use in production.</p>"},{"location":"middlewares/#authorizemiddleware","title":"AuthorizeMiddleware","text":"<p>Use <code>AuthorizeMiddleware</code> to check abilities before executing a handler. It delegates to the authenticated user's <code>authorize</code> method and supports either class-level or instance-level checks.</p> <pre><code>@middleware(AuthorizeMiddleware(\"update\", \"post\"))\nasync def update_post(post: Post):\n    ...\n\n@middleware(AuthorizeMiddleware(\"create\", Post))\nasync def create_post():\n    ...\n</code></pre> <ul> <li>Resolves the referenced target either by name (from bound kwargs) or class.</li> <li>Raises <code>UnauthorizedException</code> when the user is missing or the policy denies.</li> <li>Ideal companion to <code>ModelBindingMiddleware</code> so instance checks receive the already-bound model.</li> </ul>"},{"location":"middlewares/#belongstomiddleware","title":"BelongsToMiddleware","text":"<p><code>BelongsToMiddleware</code> ensures relational integrity between two bound models. It is particularly useful for nested resources where both parent and child models are injected into the handler.</p> <pre><code>@middleware(BelongsToMiddleware(\"organisation_member\", \"organisation\"))\nasync def show_invitation(\n    organisation: Organisation,\n    organisation_member: OrganisationMember,\n):\n    ...\n</code></pre> <ul> <li>Verifies that the child model's foreign key matches the parent's identifier.</li> <li>Supports custom <code>foreign_key</code> and <code>parent_key</code> parameters when naming differs.</li> <li>Raises <code>NotFoundException</code> to avoid leaking the existence of other tenants' data.</li> </ul>"},{"location":"middlewares/#etagmiddleware","title":"EtagMiddleware","text":"<p><code>EtagMiddleware</code> adds HTTP caching semantics to JSON responses by computing a SHA1 digest of the serialised body and comparing it with the incoming <code>If-None-Match</code> header.</p> <pre><code>@middleware(EtagMiddleware())\nasync def list_posts():\n    return PostsResource(await Post.all())\n</code></pre> <ul> <li>Returns <code>304 Not Modified</code> when the computed ETag matches the request header.</li> <li>Automatically sets the <code>ETag</code> response header on cacheable responses.</li> <li>Keeps handlers unchanged; simply wrap the existing route.</li> </ul>"},{"location":"middlewares/#throttlemiddleware","title":"ThrottleMiddleware","text":"<p><code>ThrottleMiddleware</code> provides per-identity request limiting with a configurable window and request count.</p> <pre><code>@middleware(ThrottleMiddleware(limit=60, window_seconds=60))\nasync def sensitive_action():\n    ...\n</code></pre> <ul> <li>Identifies clients via the authenticated user's id or, as a fallback, their IP address.</li> <li>Uses Redis-backed counters to track request volume.</li> <li>Raises <code>TooManyRequestsException</code> when the limit is exceeded, returning a <code>429</code> response.</li> </ul> <p>Combine these middlewares as needed to layer authorisation, data protection, performance, and rate limiting policies on a per-route basis.</p>"},{"location":"models/","title":"Models","text":"<p>FastApp models are lightweight dataclasses layered on top of Motor. They include change tracking, Mongo-friendly helpers, and Laravel-inspired relationships.</p>"},{"location":"models/#generating-a-model","title":"Generating a model","text":"<p>Use the CLI to scaffold a new model. Naming convention: omit the <code>Model</code> suffix in both the class and filename.</p> <pre><code>fast-app make model User\n</code></pre> <p>This generates <code>app/models/user.py</code> with a <code>User</code> class stub. Add field annotations directly on the dataclass:</p> <pre><code>from fast_app import Model\n\nclass User(Model):\n    email: str\n    name: str | None = None\n</code></pre> <p>Fields declared on the class become persisted attributes. Avoid suffixing the file or class with <code>Model</code>; FastApp handles that implicitly.</p>"},{"location":"models/#creating-and-saving","title":"Creating and saving","text":"<p>Instantiate the model and call <code>save()</code> to insert or update depending on whether <code>_id</code> is set:</p> <pre><code>user = User(email=\"john@example.com\", name=\"John\")\nawait user.save()  # inserts a document and assigns user._id\n\n# Update attributes and save again\nuser.name = \"John Smith\"\nawait user.save()  # triggers update and refreshes fields\n</code></pre> <p>Alternatively, use the convenience class methods:</p> <pre><code>created = await User.create({\"email\": \"jane@example.com\", \"name\": \"Jane\"})\nfirst = await User.first()   # returns first document\nexists = await User.exists({\"email\": \"jane@example.com\"})   # True or False\n</code></pre>"},{"location":"models/#reading-and-querying","title":"Reading and querying","text":"<p>The contract exposes familiar helpers:</p> <ul> <li><code>User.find(query)</code> \u2192 list of <code>User</code></li> <li><code>User.find_one(query)</code> \u2192 single <code>User | None</code></li> <li><code>User.find_by_id(id)</code> \u2192 fetch by ObjectId or hex string</li> <li><code>User.find_or_fail(query)</code> / <code>find_by_id_or_fail(id)</code> \u2192 raise <code>ModelNotFoundException</code> on absence</li> <li><code>User.search(query)</code> \u2192 text search across fields and configured relations</li> <li><code>User.scope()</code> \u2192 fluent query builder</li> </ul> <p>Example:</p> <pre><code>users = await User.find({\"active\": True}, sort=[(\"created_at\", -1)])\nmaybe = await User.find_one({\"email\": \"john@example.com\"})\nby_id = await User.find_by_id(\"66f2d3...\")\n\nif maybe:\n    await maybe.update({\"name\": \"John Updated\"})\n\ncount = await User.count({\"active\": True})\n</code></pre>"},{"location":"models/#relationships","title":"Relationships","text":"<p>Models include three helpers for simple relationships. Define async accessors on the model to make usage explicit and keep circular imports at bay.</p> <pre><code>from __future__ import annotations\n\nfrom typing import Optional, TYPE_CHECKING\n\nfrom fast_app import Model\n\nif TYPE_CHECKING:\n    from app.models.lead import Lead\n\n\nclass User(Model):\n    name: str\n\n    async def lead(self) -&gt; Optional['Lead']:\n        from app.models.lead import Lead   # local import to avoid circular dependency\n        return await self.has_one(Lead)\n\n\nclass Lead(Model):\n    user_id: ObjectId\n\n    async def user(self) -&gt; Optional[User]:\n        return await self.belongs_to(User)\n\n\nuser = await User.find_by_id(user_id)\nlead = await user.lead()     # has_one helper under the hood\nuser = await lead.user()\n</code></pre> <ul> <li><code>belongs_to(parent_model, parent_key=\"_id\", child_key=\"modelname_id\")</code></li> <li><code>has_one(child_model, parent_key=\"_id\", child_key=\"modelname_id\")</code></li> <li><code>has_many(child_model, parent_key=\"_id\", child_key=\"modelname_id\")</code></li> </ul> <p>Override <code>parent_key</code> or <code>child_key</code> for non-standard schemas. Each helper automatically converts string IDs to <code>ObjectId</code> when <code>is_object_id</code> is <code>True</code> (default). When you expose relationships as methods, use <code>TYPE_CHECKING</code> imports (as above) to keep type hints without triggering runtime import cycles.</p>"},{"location":"models/#change-tracking-and-persistence","title":"Change tracking and persistence","text":"<p>Setting attributes records dirty fields in <code>self.clean</code>. <code>save()</code> or <code>update()</code> writes only changed fields and updates <code>updated_at</code>. Successful operations trigger observer hooks and bump the collection cache version, which invalidates cached queries.</p> <pre><code>user.set(\"name\", \"Alice\")\nawait user.save()\n\nawait User.update_many({\"active\": False}, {\"$set\": {\"active\": True}})\n</code></pre> <p>Use <code>touch()</code> to bump the <code>updated_at</code> timestamp without modifying other fields.</p>"},{"location":"notifications/","title":"Notifications","text":"<p>Notifications provide a unified interface for sending messages across multiple channels\u2014email, SMS, push notifications, Slack, etc. Define notification classes with channel-specific formatting and let the framework handle delivery via the queue.</p>"},{"location":"notifications/#making-models-notifiable","title":"Making models notifiable","text":"<p>Models that receive notifications need the <code>@notifiable</code> decorator:</p> <pre><code>from fast_app import Model\nfrom fast_app.decorators.model_decorators import notifiable\n\n\n@notifiable\nclass User(Model):\n    name: str\n    email: str | None = None\n    phone: str | None = None\n</code></pre> <p>The decorator adds notification helpers to the model (currently just marks it as notifiable; channels determine routing logic).</p>"},{"location":"notifications/#generating-notifications-and-channels","title":"Generating notifications and channels","text":"<p>Use the CLI to scaffold notification and channel classes:</p> <pre><code>fast-app make notification EmailOTP\nfast-app make notification_channel MailChannel\n</code></pre> <p>Notifications go to <code>app/notifications/</code>, channels to <code>app/notification_channels/</code>.</p> <p>For common channels (mail, Telegram), publish pre-built templates:</p> <pre><code>fast-app publish mail_notification_channel\nfast-app publish telegram_notification_channel\n</code></pre>"},{"location":"notifications/#creating-a-notification","title":"Creating a notification","text":"<p>Notifications extend <code>fast_app.contracts.notification.Notification</code> and define:</p> <ul> <li><code>via(notifiable)</code> \u2014 returns a list of channel instances</li> <li>Channel-specific methods like <code>to_mail(notifiable)</code>, <code>to_sms(notifiable)</code>, etc.</li> </ul> <pre><code>from typing import TYPE_CHECKING\n\nfrom fast_app import Notification\nfrom fast_app.integrations.notifications.mail import MailMessage\nfrom app.notification_channels.mail_channel import MailChannel\n\nif TYPE_CHECKING:\n    from fast_app import Model, NotificationChannel\n    from app.models.email_otp import EmailOTP\n\n\nclass EmailOTPNotification(Notification):\n    def __init__(self, email_otp: \"EmailOTP\"):\n        self.email_otp = email_otp\n\n    def via(self, notifiable: \"Model\") -&gt; list[\"NotificationChannel\"]:\n        return [MailChannel()]\n\n    async def to_mail(self, notifiable: \"Model\") -&gt; MailMessage:\n        otp = str(self.email_otp.otp)\n        otp = otp[:3] + \"-\" + otp[3:] if len(otp) &gt; 3 else otp\n\n        return MailMessage(\n            subject=f\"\ud83d\udd11 {otp} is your verification code\",\n            body=f\"Your code: {otp}. Expires in 15 minutes.\",\n        )\n</code></pre> <p>The notification class holds state (e.g., <code>email_otp</code>) and transforms it into channel-specific payloads.</p>"},{"location":"notifications/#creating-a-channel","title":"Creating a channel","text":"<p>Channels extend <code>fast_app.contracts.notification_channel.NotificationChannel</code> and implement <code>send(notifiable, notification)</code>:</p> <pre><code>from typing import TYPE_CHECKING\n\nfrom fast_app import NotificationChannel\nfrom fast_app.integrations.notifications.mail import Mail\n\nif TYPE_CHECKING:\n    from app.models.user import User\n    from fast_app import Notification\n\n\nclass MailChannel(NotificationChannel):\n    async def send(self, notifiable: \"User\", notification: \"Notification\"):\n        if receiver_mail := notifiable.get(\"email\"):\n            await Mail.send(receiver_mail, await notification.to_mail(notifiable))\n</code></pre> <p>Channels: 1. Extract recipient details from the <code>notifiable</code> model (e.g., <code>user.email</code>) 2. Call the notification's channel-specific method (<code>to_mail</code>) 3. Send via the integration (e.g., <code>Mail.send</code>)</p>"},{"location":"notifications/#sending-notifications","title":"Sending notifications","text":"<p>Call <code>await notification.send(notifiable)</code> from anywhere in your application:</p> <pre><code>from app.notifications.email_otp_notification import EmailOTPNotification\n\notp = await EmailOTP.create({\"user_id\": user.id, \"otp\": \"123456\"})\nawait EmailOTPNotification(otp).send(user)\n</code></pre> <p>Under the hood, <code>send()</code>: 1. Calls <code>via(notifiable)</code> to get channels 2. Enqueues <code>channel.send(notifiable, self)</code> for each channel via <code>fast_app.core.queue.queue</code> 3. Workers process deliveries asynchronously (when <code>QUEUE_DRIVER=async_farm</code>)</p>"},{"location":"notifications/#built-in-integrations","title":"Built-in integrations","text":"<p>FastApp ships with helpers for common channels:</p>"},{"location":"notifications/#mail","title":"Mail","text":"<pre><code>from fast_app.integrations.notifications.mail import Mail, MailMessage\n\nmessage = MailMessage(\n    subject=\"Welcome!\",\n    body=\"Thanks for signing up.\",\n    html=\"&lt;p&gt;Thanks for signing up.&lt;/p&gt;\",\n)\nawait Mail.send(\"user@example.com\", message)\n</code></pre> <p>Configure via environment variables: <code>MAIL_HOST</code>, <code>MAIL_PORT</code>, <code>MAIL_USERNAME</code>, <code>MAIL_PASSWORD</code>, <code>MAIL_FROM</code>.</p>"},{"location":"notifications/#expo-push-notifications","title":"Expo Push Notifications","text":"<pre><code>from fast_app.integrations.notifications.expo import Expo\n\nawait Expo.send_push_notification(\n    tokens=[\"ExponentPushToken[...]\"],\n    title=\"New message\",\n    body=\"You have a new chat message\",\n)\n</code></pre> <p>Requires <code>EXPO_ACCESS_TOKEN</code>.</p>"},{"location":"notifications/#slack","title":"Slack","text":"<pre><code>from fast_app.integrations.notifications.slack import Slack\n\nawait Slack.send_message(\n    channel=\"#alerts\",\n    text=\"Deployment completed successfully\",\n)\n</code></pre> <p>Configure via <code>SLACK_WEBHOOK_URL</code>.</p>"},{"location":"notifications/#custom-channels","title":"Custom channels","text":"<p>Create a custom channel for any service:</p> <pre><code>from fast_app import NotificationChannel\n\n\nclass SMSChannel(NotificationChannel):\n    async def send(self, notifiable, notification):\n        phone = notifiable.get(\"phone\")\n        message = await notification.to_sms(notifiable)\n        await twilio_client.messages.create(to=phone, body=message)\n</code></pre> <p>Add a <code>to_sms()</code> method to your notifications:</p> <pre><code>class EmailOTPNotification(Notification):\n    def via(self, notifiable):\n        channels = [MailChannel()]\n        if notifiable.get(\"phone\"):\n            channels.append(SMSChannel())\n        return channels\n\n    async def to_sms(self, notifiable):\n        return f\"Your verification code: {self.email_otp.otp}\"\n</code></pre>"},{"location":"notifications/#tips","title":"Tips","text":"<ul> <li>Use <code>via(notifiable)</code> to conditionally select channels based on user preferences or availability (e.g., only send SMS if phone is present).</li> <li>Keep notification classes stateless except for the data they carry; channels handle delivery logic.</li> <li>Test notifications by calling <code>notification.to_mail(user)</code> directly without invoking <code>send()</code>.</li> <li>Combine with events: dispatch an event that triggers a listener which sends a notification.</li> </ul> <p>Notifications centralize message formatting and delivery, making it easy to support new channels or update content without touching controllers.</p>"},{"location":"observers/","title":"Observers","text":"<p>Observers let you hook into a model\u2019s lifecycle (create, update, delete) without polluting the model itself. Each observer receives the model instance and can mutate it, halt the operation, or trigger side effects.</p>"},{"location":"observers/#generating-an-observer","title":"Generating an observer","text":"<p>Scaffold a new observer with the CLI:</p> <pre><code>fast-app make observer LeadObserver\n</code></pre> <p>The generator creates <code>app/observers/lead_observer.py</code> with a class stub derived from <code>fast_app.contracts.observer.Observer</code>.</p>"},{"location":"observers/#lifecycle-hooks","title":"Lifecycle hooks","text":"<p>The base contract defines six async hooks:</p> <ul> <li><code>on_creating(model)</code> \u2014 runs before the model is inserted.</li> <li><code>on_created(model)</code> \u2014 runs after insert completes.</li> <li><code>on_updating(model)</code> \u2014 runs before an update.</li> <li><code>on_updated(model)</code> \u2014 runs after update succeeds.</li> <li><code>on_deleting(model)</code> \u2014 runs before deletion.</li> <li><code>on_deleted(model)</code> \u2014 runs after deletion.</li> </ul> <p>All hooks execute inside the model\u2019s event loop context, so you can await other async calls.</p>"},{"location":"observers/#relationship-to-models","title":"Relationship to models","text":"<p>Models keep track of observers via <code>model.register_observer(observer_instance)</code>. During lifecycle events, the model invokes the relevant hook on each registered observer. Dirty tracking (<code>model.clean</code>) records which fields changed; inside <code>on_creating</code>/<code>on_updating</code> you can inspect <code>model.clean</code> to see the old values.</p> <pre><code>from fast_app.contracts.observer import Observer\n\n\nclass LeadObserver(Observer):\n    async def on_creating(self, model):\n        # Ensure name defaults before insertion\n        if not model.name:\n            model.name = \"Unnamed\"\n\n    async def on_updating(self, model):\n        previous_email = model.clean.get(\"email\")\n        if previous_email and previous_email != model.email:\n            await audit_log(model.id, \"email_changed\", previous_email, model.email)\n</code></pre> <p>After <code>save()</code> completes, the model refresh resets <code>model.clean</code>, so dirty fields are only available during the hook execution.</p>"},{"location":"observers/#auto-discovery-and-manual-registration","title":"Auto-discovery and manual registration","text":"<p>When you import <code>import fast_app.boot</code>, the framework automatically discovers observers in <code>app/observers/</code> whose filenames and class names match your models (e.g., <code>lead_observer.py</code> with <code>LeadObserver</code>). The matching model registers the observer by default.</p> <p>If an observer is not auto-registered, attach it manually with the <code>register_observer</code> decorator:</p> <pre><code>from fast_app.decorators.model_decorators import register_observer\nfrom app.observers.lead_observer import LeadObserver\n\n\n@register_observer(LeadObserver)\nclass Lead(Model):\n    ...\n</code></pre> <p>The decorator wraps the model\u2019s <code>__init__</code> to register the observer instance every time the model is instantiated, ensuring hooks fire during persistence operations.</p>"},{"location":"observers/#mutating-models-inside-hooks","title":"Mutating models inside hooks","text":"<p>Because hook methods receive the concrete model instance, you can modify attributes before the database write happens. Common use cases include:</p> <ul> <li>Normalizing or casting incoming values (<code>model.email = model.email.lower()</code>).</li> <li>Setting default metadata (timestamps, slugs).</li> <li>Running cross-collection integrity checks.</li> </ul> <p>Any changes made in <code>on_creating</code> or <code>on_updating</code> become part of the persisted payload. </p> <p>Observers provide a single place to centralize domain-side effects tied to persistence, keeping controllers and models lean.</p>"},{"location":"policies/","title":"Policies","text":"<p>Policies encapsulate authorization logic for a model. Pair them with the <code>Authorizable</code> mixin to give users (<code>can</code>, <code>cannot</code>, <code>authorize</code>) checks and wire them into middleware.</p>"},{"location":"policies/#generating-a-policy","title":"Generating a policy","text":"<p>Use the CLI to scaffold a policy class:</p> <pre><code>fast-app make policy ChatPolicy\n</code></pre> <p>This command creates <code>app/policies/chat_policy.py</code> with a class inheriting from <code>fast_app.contracts.policy.Policy</code>.</p>"},{"location":"policies/#structure-of-a-policy","title":"Structure of a policy","text":"<p>Each policy exposes async methods that return <code>True</code> or <code>False</code> for specific abilities. The optional <code>before</code> hook runs prior to any ability method\u2014return <code>True</code> to short-circuit with a grant, <code>False</code> to deny outright, or <code>None</code> to fall through to the method-specific check.</p> <pre><code>from typing import Optional, TYPE_CHECKING\n\nfrom fast_app import Policy\n\nif TYPE_CHECKING:\n    from app.models.user import User\n    from app.models.chat import Chat\n\n\nclass ChatPolicy(Policy):\n    async def before(self, ability: str, user: \"User\") -&gt; Optional[bool]:\n        if user.is_admin:\n            return True\n        return None\n\n    async def access(self, chat: \"Chat\", user: \"User\") -&gt; bool:\n        return user.id == chat.created_by_user_id\n\n    async def delete(self, chat: \"Chat\", user: \"User\") -&gt; bool:\n        return user.id == chat.created_by_user_id and not chat.archived\n</code></pre> <p>Define one method per ability (e.g., <code>view</code>, <code>update</code>, <code>delete</code>). Ability names are arbitrary strings, but should stay consistent with your controller usage.</p>"},{"location":"policies/#wiring-policies-to-models","title":"Wiring policies to models","text":"<p>Attach a policy to a model by importing it and setting the <code>policy</code> class attribute, or use the <code>Authorizable</code> helper decorator. Models that represent authenticated users should include the <code>Authorizable</code> mixin so they gain <code>can</code>, <code>cannot</code>, and <code>authorize</code> methods.</p> <pre><code>from fast_app.core.mixins.authorizable import Authorizable\nfrom fast_app.templates.make.policy import ChatPolicy\n\n\nclass User(Model, Authorizable):\n    pass\n\n\nclass Chat(Model):\n    policy = ChatPolicy()\n</code></pre> <p><code>Authorizable.can(ability, target)</code> resolves the policy attached to the target model or class, runs the <code>before</code> hook, then invokes the ability method. <code>cannot</code> negates the result, and <code>authorize</code> raises <code>ForbiddenException</code> on failure.</p>"},{"location":"policies/#using-policies-in-routes","title":"Using policies in routes","text":"<p>Apply <code>AuthorizeMiddleware</code> to protect endpoints declaratively. The middleware retrieves the current user from <code>quart.g</code>, resolves the target, and calls <code>user.authorize(ability, target)</code>.</p> <pre><code>Route.group(\"/chat\", middlewares=[AuthMiddleware], routes=[\n    Route.post(\"/\", chat_controller.store),\n    Route.get(\"/\", chat_controller.index),\n    Route.post(\"/&lt;chat_id&gt;/message\", chat_controller.message, [AuthorizeMiddleware(\"access\", \"chat\")]),\n    Route.post(\"/&lt;chat_id&gt;/feedback\", chat_controller.feedback, [AuthorizeMiddleware(\"access\", \"chat\")]),\n    Route.get(\"/&lt;chat_id&gt;\", chat_controller.show, [AuthorizeMiddleware(\"access\", \"chat\")]),\n    Route.delete(\"/&lt;chat_id&gt;\", chat_controller.destroy, [AuthorizeMiddleware(\"access\", \"chat\")]),\n])\n</code></pre> <p>In this example, <code>ModelBindingMiddleware</code> converts <code>chat_id</code> into a <code>Chat</code> instance and stores it in the handler kwargs (<code>chat</code>). The middleware targets that argument by name and tests the <code>access</code> ability.</p>"},{"location":"policies/#tips","title":"Tips","text":"<ul> <li>Use <code>before</code> to centralize global privileges (admins, owners) and let individual methods handle nuanced checks.</li> <li>Keep policies stateless\u2014no database access\u2014so they execute quickly. Fetch required context in controllers before calling <code>authorize</code>.</li> <li>When an ability applies to a model class rather than an instance (e.g., <code>create</code>), pass the class to <code>authorize</code> and accept <code>None</code> as the first parameter in your policy method.</li> <li>Combine policies with <code>Authorizable</code> checks in services or background jobs; you\u2019re not limited to HTTP middleware.</li> </ul> <p>Policies offer a clean separation between authorization rules and application logic, making it easy to audit and evolve access control.</p>"},{"location":"queue/","title":"Queue","text":"<p>FastApp's queue abstraction lets you defer work to background processes. Use it for tasks that don't need immediate execution\u2014sending emails, processing uploads, generating reports, or triggering notifications\u2014so your API responses stay fast.</p>"},{"location":"queue/#drivers","title":"Drivers","text":"<p>The queue supports two execution modes controlled by the <code>QUEUE_DRIVER</code> environment variable:</p> <ul> <li>sync (default) \u2014 executes the function immediately in-process. Useful for development or small deployments where background workers aren't needed.</li> <li>async_farm \u2014 enqueues jobs to RabbitMQ and executes them on worker processes managed by the async farm supervisor.</li> </ul> <pre><code>export QUEUE_DRIVER=async_farm\n</code></pre>"},{"location":"queue/#basic-usage","title":"Basic usage","text":"<p>Call <code>queue(func, *args, **kwargs)</code> to schedule a function. Both sync and async callables are supported.</p> <pre><code>from fast_app.core.queue import queue\n\nasync def send_welcome_email(user_id: str):\n    user = await User.find_by_id(user_id)\n    await email_service.send(user.email, \"Welcome!\")\n\n# Enqueue the task\nawait queue(send_welcome_email, user_id=\"66f2d3...\")\n</code></pre> <p>The function signature must be importable (defined at module level with a dotted path). Lambdas and nested functions won't work with <code>async_farm</code>.</p>"},{"location":"queue/#timeouts","title":"Timeouts","text":"<p>When using <code>async_farm</code>, you can specify soft and hard timeouts via special kwargs:</p> <pre><code>await queue(\n    process_large_report,\n    report_id=\"abc123\",\n    __soft_timeout_s=300,   # warn after 5 minutes\n    __hard_timeout_s=600,   # force kill after 10 minutes\n)\n</code></pre> <ul> <li>Soft timeout \u2014 logs a warning and cancels the asyncio task wrapper, but the underlying work may continue until the hard timeout.</li> <li>Hard timeout \u2014 forcibly terminates the worker process after the specified duration.</li> </ul> <p>These kwargs are stripped before the function receives its arguments.</p>"},{"location":"queue/#running-workers","title":"Running workers","text":"<p>To process queued jobs with <code>async_farm</code>, start the supervisor:</p> <pre><code>fast-app work          # production\nfast-app work --tui    # development with live dashboard\n</code></pre> <p>The supervisor spawns worker processes, scales them based on queue depth, and monitors heartbeats. See the Async Farm documentation for configuration details.</p>"},{"location":"queue/#context-propagation","title":"Context propagation","text":"<p>When using <code>async_farm</code>, the current request context (from <code>fast_app.core.context.context</code>) is serialized and restored inside the worker. This means queued jobs have access to the same user, locale, or other context variables that were active when the job was enqueued.</p> <pre><code>from fast_app.core.context import context\n\ncontext.set(\"user_id\", user.id)\nawait queue(audit_action, action=\"login\")\n\n# Inside the worker, the job can access:\n# context.get(\"user_id\") \u2192 same user ID\n</code></pre>"},{"location":"queue/#requirements","title":"Requirements","text":"<p><code>async_farm</code> mode requires:</p> <ul> <li>RabbitMQ \u2014 configure via <code>RABBITMQ_URL</code> (defaults to <code>amqp://guest:guest@localhost:5672/</code>)</li> <li>aio-pika \u2014 installed as part of FastApp's dependencies</li> </ul> <p>For more on worker management, scaling, and diagnostics, consult the Async Farm documentation.</p>"},{"location":"quick_start/","title":"Quick Start","text":"<p>Get a FastApp project running in minutes. This guide walks you through installation, project setup, and your first endpoint.</p>"},{"location":"quick_start/#installation","title":"Installation","text":"<p>Create a virtual environment and install FastApp:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\npip install \"git+https://github.com/patrikmojzis/fast-app\"\n</code></pre>"},{"location":"quick_start/#initialize-a-project","title":"Initialize a project","text":"<p>FastApp scaffolds a complete project structure with one command:</p> <pre><code>fast-app init\n</code></pre> <p>This creates:</p> <pre><code>app/\n  app_config.py           # Optional application configuration\n  models/                 # Domain models\n  http_files/\n    controllers/          # Request handlers\n    resources/            # Response transformers\n    schemas/              # Request validators\n    middlewares/          # Custom middleware\n    routes/\n      api.py             # Route definitions\n  modules/\n    asgi/\n      app.py             # ASGI entry point\n</code></pre>"},{"location":"quick_start/#understanding-import-fast_appboot","title":"Understanding <code>import fast_app.boot</code>","text":"<p>Every Python entry point (ASGI servers, CLI scripts, worker processes) must import <code>fast_app.boot</code> as early as possible:</p> <pre><code>import fast_app.boot  # Always first\n\nfrom quart import Quart\n# ... rest of your imports\n</code></pre> <p>This import:</p> <ul> <li>Reads <code>app/app_config.py</code> if present (optional) and applies configuration</li> <li>Sets up logging (console + file handlers)</li> <li>Loads environment variables from <code>.env</code> and <code>.env.{ENV}</code></li> <li>Enables autodiscovery for observers, policies, and events when configured</li> </ul>"},{"location":"quick_start/#configuring-your-app","title":"Configuring your app","text":"<p>The <code>app/app_config.py</code> file is optional but powerful. Use it to customize framework behavior:</p> <pre><code># app/app_config.py\n\nautodiscovery = True  # Auto-register observers/policies based on naming conventions\n\nevents = {\n    UserRegistered: [SendWelcomeEmail, CreateProfile],\n}\n\nstorage_default_disk = \"s3\"\nstorage_disks = {\n    \"s3\": {\"driver\": \"s3\", \"bucket\": \"my-bucket\"},\n}\n\nlog_file_name = \"custom.log\"\n</code></pre> <p>Even without this file, <code>import fast_app.boot</code> handles logging and environment setup.</p>"},{"location":"quick_start/#create-your-first-route","title":"Create your first route","text":"<p>Open <code>app/http_files/routes/api.py</code> and define routes:</p> <pre><code>from fast_app import Route\n\nasync def ping():\n    return {\"message\": \"pong\"}\n\nroutes = [\n    Route.get(\"/ping\", ping),\n]\n</code></pre> <p>Register routes in <code>app/modules/asgi/app.py</code>:</p> <pre><code>import fast_app.boot  # Always first\n\nfrom quart import Quart\nfrom fast_app.utils.routing_utils import register_routes\nfrom app.http_files.routes.api import routes\n\napp = Quart(__name__)\nregister_routes(app, routes)\n</code></pre>"},{"location":"quick_start/#run-the-development-server","title":"Run the development server","text":"<p>Start the API with auto-reload:</p> <pre><code>fast-app serve\n</code></pre> <p>Visit <code>http://localhost:8000/ping</code> to see your response.</p>"},{"location":"quick_start/#core-concepts","title":"Core concepts","text":"<p>FastApp composes these building blocks:</p> <ul> <li>Routes \u2014 declarative HTTP definitions with middleware support</li> <li>Schemas \u2014 Pydantic validators with async rules</li> <li>Models \u2014 async ODM for MongoDB with observers and policies</li> <li>Resources \u2014 transform models into JSON responses</li> <li>Controllers \u2014 orchestrate validation, domain logic, and responses</li> <li>Observers \u2014 lifecycle hooks (on_created, on_updated, etc.)</li> <li>Policies \u2014 authorization rules enforced via middleware or manual checks</li> <li>Events \u2014 decouple side effects from controllers</li> </ul> <p>Typical request flow: <code>Route \u2192 Middlewares \u2192 Controller \u2192 Schema \u2192 Model \u2192 Resource</code></p>"},{"location":"quick_start/#next-steps","title":"Next steps","text":"<ul> <li>Read Routes to learn grouping, resource routes, and middleware</li> <li>Explore Models for database operations and relationships</li> <li>Check Schemas for validation patterns</li> <li>Review API Helpers for pagination and filtering utilities</li> <li>Set up Queue for background jobs</li> <li>Configure Broadcasting for real-time features</li> </ul> <p>FastApp follows Laravel-inspired conventions to keep your code organized and predictable. Dive into the sections above to unlock its full potential.</p>"},{"location":"resources/","title":"Resources","text":"<p>Resources transform models into API-friendly payloads. They give you a dedicated layer to enrich responses, preload relationships, and keep controllers slim.</p>"},{"location":"resources/#generating-a-resource","title":"Generating a resource","text":"<p>Use the CLI to scaffold a new resource:</p> <pre><code>fast-app make resource Stock\n</code></pre> <p>The generator creates <code>app/http_files/resources/stock_resource.py</code> with a class stub inheriting from <code>fast_app.contracts.resource.Resource</code> (or your local <code>ResourceBase</code>).</p>"},{"location":"resources/#implementing-to_dict","title":"Implementing <code>to_dict</code>","text":"<p>Every resource must implement <code>async def to_dict(self, data: Model) -&gt; dict</code>. This method receives a single model instance and returns the serializable representation. Resolve relationships or perform async lookups before returning the payload.</p> <pre><code>from fast_app import Resource\n\n\nclass StockResource(Resource):\n    async def to_dict(self, stock):\n        return {\n            \"_id\": stock.id,\n            \"name\": stock.name,\n            \"rep\": RepResource(stock.rep()),\n        }\n</code></pre> <p>Resources can return nested resources or lists; the base class resolves any nested <code>Resource</code> instances and awaits them concurrently.</p>"},{"location":"resources/#returning-resources-from-controllers","title":"Returning resources from controllers","text":"<p>Controllers can return a resource instance directly. <code>ResourceResponseMiddleware</code> (automatically applied by <code>register_routes</code>) calls <code>to_response()</code> and serializes the payload.</p> <pre><code># Route.get(\"/stocks/&lt;stock_id&gt;\")\nasync def show(stock: Stock):\n    return StockResource(stock)\n</code></pre> <p>Pass a list of models to return multiple records: <code>return StockResource(await Stock.find({...}))</code>. The base class handles gathering each item\u2019s <code>to_dict</code> concurrently.</p> <p>Resources provide an elegant, testable layer between domain models and API responses, making it easy to evolve your response structure without touching controllers.</p>"},{"location":"rooms/","title":"Rooms","text":"<p>Rooms encapsulate authorization and routing logic for Socket.IO channels. Each room subclass inherits from <code>fast_app.contracts.room.Room</code> and controls who can join and how a room identifier is derived.</p>"},{"location":"rooms/#generating-a-room","title":"Generating a room","text":"<pre><code>fast-app make room ChatRoom\n</code></pre> <p>The generator places a stub in <code>app/socketio/rooms/chat_room.py</code>. Align with the recommended folder layout (<code>app/socketio/rooms/</code> alongside <code>events/</code> and <code>namespaces/</code>).</p>"},{"location":"rooms/#anatomy-of-a-room-class","title":"Anatomy of a room class","text":"<pre><code>from typing import Any, Optional, TYPE_CHECKING\n\nfrom fast_app import Room\nfrom app.models.chat import Chat\n\nif TYPE_CHECKING:\n    from app.models.user import User\n\n\nclass ChatRoom(Room):\n    @classmethod\n    async def extract_room_identifier(cls, session: Any, data: dict[str, Any]) -&gt; str:\n        if not data.get(\"chat_id\"):\n            raise ValueError(\"chat_id is required\")\n        return data[\"chat_id\"]\n\n    @classmethod\n    async def can_join(cls, session: Any, data: dict[str, Any]) -&gt; bool:\n        user: Optional[\"User\"] = session.get(\"user\")\n        if not user or not data.get(\"chat_id\"):\n            return False\n\n        chat = await Chat.find_by_id(data[\"chat_id\"])\n        if not chat:\n            return False\n\n        return await user.can(\"access\", chat)\n</code></pre> <ul> <li>Constructor \u2014 room subclasses usually accept a domain identifier (e.g., <code>chat_id</code>) and pass it to <code>Room.__init__</code>. When you instantiate <code>ChatRoom(chat.id)</code> inside <code>broadcast_on()</code>, this value becomes the canonical room name.</li> <li><code>extract_room_identifier</code> returns the actual room string (e.g., primary key). Use the Socket.IO session and incoming payload to determine context.</li> <li><code>can_join</code> evaluates whether the current user can subscribe. Leverage policies via <code>user.can(...)</code> for granular control.</li> </ul>"},{"location":"rooms/#registering-rooms-with-namespaces","title":"Registering rooms with namespaces","text":"<p>Use <code>@register_room(RoomSubclass)</code> to attach rooms to a namespace. When clients join, the decorator ensures <code>extract_room_identifier</code> and <code>can_join</code> run.</p> <pre><code>from socketio import AsyncNamespace\nfrom fast_app.decorators.namespace_decorator import register_room\nfrom app.socketio.rooms.chat_room import ChatRoom\n\n\n@register_room(ChatRoom)\nclass GlobalNamespace(AsyncNamespace):\n    def __init__(self) -&gt; None:\n        super().__init__(\"/\")\n\n    async def on_connect(self, sid, environ, auth):\n        await authenticate(self, sid, environ, auth)\n</code></pre> <p>The namespace can expose <code>on_join_chat</code> or similar handlers that accept a payload containing <code>chat_id</code>. Registered rooms will enforce authorization.</p>"},{"location":"rooms/#tips","title":"Tips","text":"<ul> <li>Store authenticated user objects in the session during <code>on_connect</code> so room guards have access to policies.</li> <li>Mirror the constructor signature (<code>__init__(room_value)</code>) when instantiating the room class elsewhere; <code>extract_room_identifier</code> should return the same value so clients and server agree on the channel name.</li> <li>Raise descriptive errors in <code>extract_room_identifier</code> to surface client mistakes early.</li> <li>Keep room logic small; delegate heavy lifting (loading chat, verifying permissions) to models or services.</li> </ul> <p>With rooms defined, client connections are filtered before they receive any broadcast events.</p>"},{"location":"routes/","title":"Routing","text":"<p>FastApp routes mirror the Laravel style you might know from PHP frameworks. Define declarative <code>Route</code> objects, then register them against your Quart application with <code>register_routes</code>. A typical project keeps these definitions in <code>app/http_files/routes/api.py</code> to keep HTTP wiring in one place.</p>"},{"location":"routes/#declaring-routes","title":"Declaring routes","text":"<p>Import the <code>Route</code> contract and compose a list of routes. Each HTTP verb has a convenience constructor:</p> <ul> <li><code>Route.get(path, handler, middlewares=None)</code></li> <li><code>Route.post(...)</code></li> <li><code>Route.put(...)</code></li> <li><code>Route.patch(...)</code></li> <li><code>Route.delete(...)</code></li> <li><code>Route.options(...)</code></li> <li><code>Route.head(...)</code></li> </ul> <p>Handlers can be callables or coroutine functions. Middlewares accept either middleware classes implementing <code>fast_app.contracts.middleware.Middleware</code>, instances, or simple callables that wrap the handler.</p> <pre><code>from fast_app import Route, ThrottleMiddleware\nfrom app.http_files.controllers import ping_controller\n\nroutes = [\n    Route.get(\"/ping\", ping_controller.show),\n    Route.post(\"/signup\", auth_controller.register, [ThrottleMiddleware(limit=10, window_seconds=60)]),\n]\n</code></pre>"},{"location":"routes/#route-groups","title":"Route groups","text":"<p>Use <code>Route.group()</code> to share prefixes or middleware across nested routes. Groups can be nested arbitrarily, and you can mix <code>prefix</code> and <code>middlewares</code> arguments:</p> <pre><code>from app.http_files.middlewares import AuthMiddleware, BusinessMiddleware\n\nroutes = [\n    Route.group(\"/auth\", routes=[\n        Route.post(\"/dispatch\", auth_controller.dispatch),\n        Route.post(\"/exchange\", auth_controller.exchange),\n        Route.delete(\"/\", auth_controller.logout, [AuthMiddleware]),\n    ]),\n    Route.group(\n        middlewares=[AuthMiddleware, BusinessMiddleware],\n        routes=[\n            Route.get(\"/chat/history\", chat_controller.get_history),\n            # ... more nested routes\n        ],\n    ),\n]\n</code></pre> <p>When you call <code>Route.group(prefix=\"/reports\", routes=[...])</code>, all nested paths inherit the <code>/reports</code> prefix. Middleware declared on the group runs before route-specific middleware, and global middlewares such as <code>HandleExceptionsMiddleware</code> and <code>ResourceResponseMiddleware</code> are injected automatically when you register the routes.</p>"},{"location":"routes/#resource-routes","title":"Resource routes","text":"<p><code>Route.resource(path, controller)</code> generates a small CRUD route group. The controller must expose the following callables:</p> <ul> <li><code>index</code> \u2014 list resources (<code>GET path/</code>)</li> <li><code>show</code> \u2014 fetch a resource (<code>GET path/&lt;id&gt;</code>)</li> <li><code>store</code> \u2014 create a resource (<code>POST path/</code>)</li> <li><code>update</code> \u2014 update a resource (<code>PATCH path/&lt;id&gt;</code>)</li> <li><code>destroy</code> \u2014 delete a resource (<code>DELETE path/&lt;id&gt;</code>)</li> </ul> <p>Method names can be overridden by passing <code>controller_methods</code>. For example:</p> <pre><code>Route.resource(\n    \"/lead\",\n    lead_controller,\n    controller_methods={\"update\": \"patch\", \"destroy\": \"soft_delete\"},\n)\n</code></pre> <p>If you prefer an alternate path parameter (defaults to <code>&lt;lead_id&gt;</code> based on the slug), supply <code>parameter=\"&lt;slug&gt;\"</code>.</p> <p>Because <code>Route.resource</code> returns a group, you can nest additional routes alongside it:</p> <pre><code>routes = [\n    Route.resource(\"/order\", order_controller),\n    Route.group(\"/order/&lt;order_id&gt;\", routes=[\n        Route.post(\"/attachment\", order_controller.upload_attachments),\n        Route.delete(\"/attachment/&lt;file_id&gt;\", order_controller.remove_attachment),\n    ]),\n]\n</code></pre>"},{"location":"routes/#registering-routes-with-quart","title":"Registering routes with Quart","text":"<p>Once your list is ready, register it with the Quart app. <code>register_routes</code> flattens groups, applies middleware ordering, and calls <code>app.add_url_rule</code> for every definition.</p> <pre><code>from quart import Quart\nfrom fast_app.utils.routing_utils import register_routes\nfrom app.http_files.routes.api import routes\n\napp = Quart(__name__)\nregister_routes(app, routes)\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p><code>register_routes</code> injects global middlewares in the following order: <code>HandleExceptionsMiddleware</code>, <code>ModelBindingMiddleware</code>, <code>SchemaValidationMiddleware</code>, user-specified middlewares, and finally <code>ResourceResponseMiddleware</code>. This ensures consistent request handling regardless of where your routes live.</p>"},{"location":"routes/#recommended-project-structure","title":"Recommended project structure","text":"<p>Keep HTTP routes close to controllers and schemas. A common layout:</p> <pre><code>app/\n  http_files/\n    routes/\n      api.py          # Route list exported as `routes`\n    controllers/\n      auth_controller.py\n      lead_controller.py\n    middlewares/\n      auth_middleware.py\n</code></pre> <p>Import <code>routes</code> from that module inside your Quart entry point (e.g., <code>app/modules/asgi/app.py</code>) to keep the route table declarative and discoverable.</p>"},{"location":"scheduler/","title":"Scheduler","text":""},{"location":"scheduler/#scheduler","title":"scheduler","text":"<p>Simple distributed scheduler using Redis locks.</p>"},{"location":"scheduler/#api","title":"API","text":"<ul> <li>run_scheduler(jobs): forever loop that acquires per-job lock and enqueues job via <code>queue()</code> once per interval.</li> </ul> <p>Job spec: <code>{ \"run_every_s\": int, \"function\": callable, \"identifier\": optional[str] }</code>. Identifier defaults to <code>module:qualname</code>.</p>"},{"location":"scheduler/#example","title":"Example","text":"<pre><code>from fast_app.core.scheduler import run_scheduler\nimport asyncio\n\nasync def do_work():\n    ...\n\nasyncio.run(run_scheduler([\n  {\"run_every_s\": 60, \"function\": do_work},\n]))\n</code></pre>"},{"location":"schemas/","title":"Schemas","text":"<p>Schemas describe and validate incoming payloads. They are thin wrappers around Pydantic models with an additional async validation layer powered by <code>fast-validation</code>.</p>"},{"location":"schemas/#generating-a-schema","title":"Generating a schema","text":"<p>Scaffold a schema with the CLI. Naming convention mirrors controllers and routes.</p> <pre><code>fast-app make schema Lead\n</code></pre> <p>The generator creates <code>app/http_files/schemas/lead.py</code> containing a <code>LeadSchema</code> stub:</p> <pre><code>from fast_app import Schema\nfrom pydantic import Field\n\n\nclass LeadSchema(Schema):\n    name: str = Field(..., max_length=120)\n</code></pre> <p>Keep schemas under <code>app/http_files/schemas/</code> so controllers and request handlers can import them easily.</p>"},{"location":"schemas/#pydantic-powered-validation","title":"Pydantic-powered validation","text":"<p>Schemas inherit from <code>fast_validation.Schema</code>, a Pydantic <code>BaseModel</code> with sensible defaults (whitespace stripping, assignment validation, enum support). You can use the full range of Pydantic field types, constraints, and validators.</p> <ul> <li>Required vs optional fields (<code>Field(..., description=\"...\")</code> vs <code>Field(None)</code>)</li> <li>Type hints for <code>EmailStr</code>, <code>constr</code>, <code>Literal</code>, <code>Annotated</code>, etc.</li> <li>Custom validators and field constraints, just like any Pydantic model.</li> </ul> <p>Reference the Pydantic documentation for exhaustive options: docs.pydantic.dev.</p> <pre><code>from pydantic import Field, EmailStr, constr\n\nclass InviteSchema(Schema):\n    email: EmailStr\n    name: constr(min_length=2, max_length=40)\n    role: Literal[\"admin\", \"editor\", \"viewer\"] = Field(..., description=\"Role in the workspace\")\n</code></pre>"},{"location":"schemas/#convenience-field-types","title":"Convenience field types","text":"<p>When I need quick coercion helpers, <code>fast_app.core.pydantic_types</code> ships a handful of annotated types that feel native to Pydantic while keeping Mongo- and JSON-friendly behaviour:</p> <ul> <li><code>ObjectIdField</code>: Accepts strings or <code>ObjectId</code> instances and serialises back to hex strings.</li> <li><code>DateField</code> and <code>DateTimeField</code>: Parse ISO strings (and datetimes with <code>Z</code>) into Python <code>date</code> / <code>datetime</code>, serialising back to ISO format.</li> <li><code>IntFromStrField</code>: Coerces numeric strings and exact floats to integers, rejecting booleans and fractional floats.</li> <li><code>JSONField</code>: Allows raw dict/list input or JSON strings and returns Python objects.</li> <li><code>ShortStr</code>: Strips whitespace and constrains length to 1\u2013255 characters.</li> </ul> <pre><code>from fast_app.core.pydantic_types import (\n    ObjectIdField,\n    DateField,\n    DateTimeField,\n    IntFromStrField,\n    ShortStr,\n)\n\n\nclass SubscriptionSchema(Schema):\n    user_id: ObjectIdField\n    plan: ShortStr\n    quota: IntFromStrField = 0\n    starts_at: DateField\n    renewed_at: DateTimeField | None = None\n\n</code></pre> <p>All of these types are plain Pydantic annotations, so they work with validators, JSON schema generation, and the automatic serialisation behaviour provided by FastApp resources.</p>"},{"location":"schemas/#async-rule-validation","title":"Async rule validation","text":"<p>After Pydantic validates structure and types, you can run additional async checks (e.g., hit the database, inspect related models). Define rules inside an inner <code>Meta</code> class using <code>Schema.Rule</code>.</p> <pre><code>from typing import Optional, Literal\nfrom pydantic import Field, EmailStr\n\nfrom fast_app import Schema\nfrom fast_app.core.pydantic_types import ObjectIdField\nfrom fast_app.core.validation_rules.exists_validator_rule import ExistsValidatorRule\nfrom app.models import Rep, County\n\n\nclass LeadSchema(Schema):\n    name: Optional[str] = Field(None, description=\"Lead's full name\")\n    email: Optional[EmailStr] = Field(None, description=\"Lead's email\")\n    rep_id: Optional[ObjectIdField] = Field(None, description=\"Assigned sales representative\")\n    county_id: Optional[ObjectIdField] = Field(None, description=\"Lead county\")\n    source: Optional[Literal[\"direct\", \"eshop\", \"pharmacy\", \"distributor\"]] = None\n\n    class Meta:\n        rules = [\n            Schema.Rule(\"$.rep_id\", [ExistsValidatorRule(allow_null=True)]),\n            Schema.Rule(\"$.county_id\", [ExistsValidatorRule(allow_null=True)]),\n        ]\n</code></pre> <p><code>Schema.Rule</code> accepts a JSONPath-like selector and a list of validator rules. Each rule receives the value, the whole payload, and a location tuple.</p> <p>Run rule validation explicitly:</p> <pre><code>payload = LeadSchema(**request.json)\nawait payload.validate()  # raises ValidationRuleException on failure\n</code></pre> <p>Framework helpers such as <code>fast_app.core.api.validate_request</code> call <code>await schema.validate()</code> for you, so most controllers only need to call the helper.</p>"},{"location":"schemas/#built-in-rules","title":"Built-in rules","text":"<ul> <li><code>ExistsValidatorRule(model=None, *, field=None, db_key=\"_id\", allow_null=False, is_object_id=True, each=False)</code> \u2014 verifies that IDs exist in the database. If <code>model</code> is omitted, the rule infers the model from the field name (e.g., <code>rep_id</code> \u2192 <code>Rep</code>). When <code>each=True</code>, every value in a list is checked.</li> </ul> <p>To write your own rule, subclass <code>fast_validation.validation_rule.ValidatorRule</code>:</p> <pre><code>from fast_validation import ValidatorRule, ValidationRuleException\n\n\nclass LongitudeRule(ValidatorRule):\n    async def validate(self, *, value, data, loc):\n        if value is None:\n            return\n        min_value, max_value = await make_db_call()\n        if not (min_value &lt;= float(value) &lt;= max_value):\n            raise ValidationRuleException(\"Longitude must be between -180 and 180\", loc=tuple(loc))\n\n\nclass LocationSchema(Schema):\n    longitude: float | None = None\n\n    class Meta:\n        rules = [Schema.Rule(\"$.longitude\", [LongitudeRule()])]\n</code></pre> <p>Rules run sequentially for each matched value; collect errors are aggregated into a single <code>ValidationRuleException</code>.</p>"},{"location":"schemas/#tips","title":"Tips","text":"<ul> <li>Use <code>Field(..., alias=\"externalName\")</code> when accepting camelCase payloads.</li> <li>Set <code>Field(default_factory=list)</code> for mutable defaults like tags or settings.</li> <li>Mark partial update schemas with optional fields and call <code>await schema.validate(partial=True)</code> to skip unset values.</li> <li>Keep schema modules small and reusable; share nested schemas (e.g., <code>LeadScheduleSchema</code>) across multiple resources.</li> </ul> <p>With schemas, you get strict structural validation from Pydantic plus async rule checks for cross-cutting invariants.</p>"},{"location":"storage/","title":"Storage","text":""},{"location":"storage/#storage","title":"storage","text":"<p>Facade over pluggable drivers with named disks and sensible defaults.</p> <p>Defaults: - <code>local</code>: <code>&lt;cwd&gt;/storage/local</code> - <code>public</code>: <code>&lt;cwd&gt;/storage/public</code></p>"},{"location":"storage/#configure","title":"Configure","text":"<pre><code>from fast_app.core.storage import Storage\n\nStorage.configure({\n  \"s3\": {\"driver\": \"boto3\", \"bucket\": \"my-bucket\", \"region\": \"eu\", \"key\": \"...\", \"secret\": \"...\"}\n}, default_disk=\"s3\")\n</code></pre> <p>Register drivers via <code>Storage.register_driver(name, cls)</code>; built\u2011ins are registered by <code>boot()</code>.</p>"},{"location":"storage/#use","title":"Use","text":"<pre><code>from fast_app.core.storage import Storage\n\nawait Storage.put(\"uploads/file.txt\", b\"data\")\nexists = await Storage.exists(\"uploads/file.txt\")\ncontent = await Storage.get(\"uploads/file.txt\")\nresp = await Storage.download(\"uploads/file.txt\", inline=False)\n</code></pre>"}]}